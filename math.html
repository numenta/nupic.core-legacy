<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Math &#8212; NuPIC Core 0.6.1.dev0
 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.6.1.dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Utilities" href="utils.html" />
    <link rel="prev" title="Types" href="types.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="utils.html" title="Utilities"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="types.html" title="Types"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">NuPIC Core 0.6.1.dev0
 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="math">
<h1>Math<a class="headerlink" href="#math" title="Permalink to this headline">¶</a></h1>
<div class="section" id="domain">
<h2>Domain<a class="headerlink" href="#domain" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt>
<span class="target" id="nupic.coreclassnupic_1_1_domain"></span><em class="property">template </em>&lt;typename <em>UInt</em>&gt;</dt>
<dt id="_CPPv2N5nupic6DomainE">
<span id="nupic::Domain"></span><em class="property">class </em><code class="descclassname">nupic::</code><code class="descname">Domain</code><a class="headerlink" href="#_CPPv2N5nupic6DomainE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A class that models the cartesian product of several ranges along several dimensions. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2NK5nupic6Domain8includesERK6Domain">
<span id="nupic::Domain::includes__DomainCRC"></span><span class="target" id="nupic.coreclassnupic_1_1_domain_1acd8dac141255eebcc782f824aae94e24"></span>bool <code class="descname">includes</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic6DomainE" title="nupic::Domain">Domain</a> &amp;<em>d</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic6Domain8includesERK6Domain" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Not strict inclusion. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="index">
<h2>Index<a class="headerlink" href="#index" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt>
<span class="target" id="nupic.coreclassnupic_1_1_index"></span><em class="property">template </em>&lt;typename <em>UInt</em>, const UInt <em>NDims</em>&gt;</dt>
<dt id="_CPPv2N5nupic5IndexE">
<span id="nupic::Index"></span><em class="property">class </em><code class="descclassname">nupic::</code><code class="descname">Index</code><a class="headerlink" href="#_CPPv2N5nupic5IndexE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong>Responsibility</strong> <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a> is a multi-dimensional index, consisting of a series of integers. </p>
<p>It is a fixed size index, where the size is fixed at compile time. The size is the parameter NDims of the template. UInt is the type of integers stored in the index.</p>
<p><strong>Rationale</strong> <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a> is useful when working multi-dimensional SparseTensors.</p>
<p><strong>Notes</strong> NDims &gt; 0 (that is, 0 is not allowed...) </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N5nupic5Index5IndexEv">
<span id="nupic::Index::Index"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1ab97d7da9a739caa1f133252b2f18cf2b"></span><code class="descname">Index</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic5Index5IndexEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Default constructor. </p>
<p>Creates an index initialized to zero. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic5Index5IndexEANDims_K4UInt">
<span id="nupic::Index::Index__UIntCA"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1a4c892bd352233542671790514b6ce121"></span><code class="descname">Index</code><span class="sig-paren">(</span><em class="property">const</em> UInt <em>i</em>[NDims]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic5Index5IndexEANDims_K4UInt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor from an array. </p>
<p>Creates an index that has the values in the given array.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">i</span></code>: [Uint[NDims] ] the values to initialize the index with </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic5Index5IndexE4UIntz">
<span id="nupic::Index::Index__UInt.z"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1af0d9b51cfce65e73f385aa9294528828"></span><code class="descname">Index</code><span class="sig-paren">(</span>UInt <em>i0</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic5Index5IndexE4UIntz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor from a list. </p>
<p>Creates an index initialized with the values passed in the list.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">i0</span></code>: [Uint...] the list of values to initialize the index with </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic5Index5IndexERK5IndexRK10value_type">
<span id="nupic::Index::Index__IndexCR.value_typeCR"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1a07b49941a3ec6c5c642535968e97faac"></span><code class="descname">Index</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5Index5IndexEv" title="nupic::Index::Index">Index</a> &amp;<em>bounds</em>, <em class="property">const</em> value_type &amp;<em>ordinal</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic5Index5IndexERK5IndexRK10value_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor from bounds and an ordinal. </p>
<p>This constructor builds the index that corresponds to the given ordinal, with the given bounds.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">bounds</span></code>: [<a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>] the bounds to use to compute the index </li>
<li><code class="docutils literal"><span class="pre">ordinal</span></code>: [UInt] the ordinal that will correspond to this index </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic5Index5IndexERK5Index">
<span id="nupic::Index::Index__IndexCR"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1a844986718471da61efa6fc7888aa50c2"></span><code class="descname">Index</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5Index5IndexEv" title="nupic::Index::Index">Index</a> &amp;<em>from</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic5Index5IndexERK5Index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">from</span></code>: [<a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>] the index to copy </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic5IndexaSERK5Index">
<span id="nupic::Index::assign-operator__IndexCR"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1a0e1599b8f0778a7fbfb47e83c849bdd5"></span><a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<code class="descname">operator=</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>from</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic5IndexaSERK5Index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assignment operator. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">from</span></code>: [<a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>] the index to copy </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic5IndexixEK4UInt">
<span id="nupic::Index::subscript-operator__UIntC"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1a36dec5187dacfc5f860416f491a153af"></span>UInt &amp;<code class="descname">operator[]</code><span class="sig-paren">(</span><em class="property">const</em> UInt <em>idx</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic5IndexixEK4UInt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Indexing operator. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">idx</span></code>: [0 &lt;= UInt &lt; NDims] index </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">[UInt&amp;]</span></code>: the value at index &#8216;idx&#8217; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic5IndexixERK4UInt">
<span id="nupic::Index::subscript-operator__UIntCRC"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1a08766c554f4ed916ce1655c8037025b8"></span>UInt <code class="descname">operator[]</code><span class="sig-paren">(</span><em class="property">const</em> UInt &amp;<em>idx</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic5IndexixERK4UInt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Const indexing operator. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">idx</span></code>: [0 &lt;= UInt &lt; NDims] index </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">[const</span></code>: UInt] the value at index &#8216;idx&#8217; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic5Index9setToZeroEv">
<span id="nupic::Index::setToZero"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1a11558976164708a0bd24a858da99592f"></span>void <code class="descname">setToZero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic5Index9setToZeroEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resets the whole index to all zeros. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic5Index5isSetEv">
<span id="nupic::Index::isSetC"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1a3d17b09bc507c6d5f890b6a694292155"></span>bool <code class="descname">isSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic5Index5isSetEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether the values in this index constitute a set or not (there are no duplicates). </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic5Index9incrementERK5Index">
<span id="nupic::Index::increment__IndexCR"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1af18788e66c4be097542f06de970cfbcf"></span>bool <code class="descname">increment</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>bounds</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic5Index9incrementERK5Index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Increments this index, using bounds as the upper bound for the iteration. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">bounds</span></code>: [<a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>] the upper bound </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">bool</span></code>: whether we&#8217;ve reached the end of the iteration or not </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic5Index9incrementERK5IndexRK5Index">
<span id="nupic::Index::increment__IndexCR.IndexCR"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1ab2351601ef3dad3a8223a0e5022e8bd8"></span>bool <code class="descname">increment</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>lb</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>ub</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic5Index9incrementERK5IndexRK5Index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Increment this index, using lb and ub as lower and upper bounds for the iteration. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">lb</span></code>: [index] the lower bound </li>
<li><code class="docutils literal"><span class="pre">ub</span></code>: [<a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>] the upper bound </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">bool</span></code>: whether we&#8217;ve reached the end of the iteration or not </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic5Index7ordinalERK5Index">
<span id="nupic::Index::ordinal__IndexCRC"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1aa5e3cf703c7e6ae36961a46274c136a7"></span>UInt <code class="descname">ordinal</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>bounds</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic5Index7ordinalERK5Index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the ordinal corresponding to the &#8220;natural&#8221; order for this index. </p>
<p>For example, with bounds = [3, 2], [0, 0] -&gt; 0, [0, 1] -&gt; 1, [1, 0] -&gt; 2, [1, 1] -&gt; 3, [2, 0] -&gt; 4, [2, 1] -&gt; 5.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">bounds</span></code>: [<a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>] the upper bound to use to compute the ordinal </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">UInt</span></code>: the ordinal for this index </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic5Index6strideERK4UInt">
<span id="nupic::Index::stride__UIntCRC"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1a0829704b7edf5c11b2ac261ae388211b"></span>UInt <code class="descname">stride</code><span class="sig-paren">(</span><em class="property">const</em> UInt &amp;<em>dim</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic5Index6strideERK4UInt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the stride for dimension dim of this <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>. </p>
<p>If the <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a> is :[6, 7, 5, 4], then: stride(0) = 7*5*4, stride(1) = 5*4, stride(2) = 4, stride(3) = 1.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dim</span></code>: [UInt] the dim for which we want the stride </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">UInt</span></code>: the stride </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic5Index8distanceERK5IndexRK5Index">
<span id="nupic::Index::distance__IndexCR.IndexCRC"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1ac130f8f54ee8dd21e816f743dbb2bc7a"></span>UInt <code class="descname">distance</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>bounds</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic5Index8distanceERK5IndexRK5Index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the distance between two indices, with respect to a given upper bound. </p>
<p>That is: distance = other.ordinal(bounds) - this-&gt;ordinal(bounds).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">bounds</span></code>: [<a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>] the upper bound </li>
<li><code class="docutils literal"><span class="pre">other</span></code>: [<a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>] the second index </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">UInt</span></code>: the distance between this and the second index </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic5Index7productEv">
<span id="nupic::Index::productC"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1a6a5602334a347645e827f68c3f41e4a0"></span>UInt <code class="descname">product</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic5Index7productEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the product of all the values in this index. </p>
<p>The result can be zero, if at least one of the indices is zero.</p>
<p><dl class="docutils">
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">UInt</span></code>: the product </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;UInt <em>R</em>&gt;</dt>
<dt id="_CPPv2NK5nupic5Index10complementER5IndexI4UInt1RE">
<span id="nupic::Index::complement__Index:UInt.R:RC"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1ae6cd1b03a6b95844f4c253c47c65da11"></span>void <code class="descname">complement</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a>&lt;UInt, R&gt; &amp;<em>idx</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic5Index10complementER5IndexI4UInt1RE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the complement of this index. </p>
<p>For example: (*this) [0, 2, 4] -(N=6)-&gt; (idx) [1, 3, 5] (*this) [0, 2] -(N=3)-&gt; (idx) [1] (*this) [0] -(N=2)-&gt; (idx) [1] (*this) [0, 1] -(N=3)-&gt; (idx) [2]</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">idx</span></code>: [Index&lt;UInt, R&gt;] the complement of this index </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;UInt <em>R</em>&gt;</dt>
<dt id="_CPPv2NK5nupic5Index7projectERK5IndexI4UInt1RER5IndexI4UInt1RE">
<span id="nupic::Index::project__Index:UInt.R:CR.Index:UInt.R:RC"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1a774404205bf6fcc89528827ee0c1ba17"></span>void <code class="descname">project</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a>&lt;UInt, R&gt; &amp;<em>dims</em>, <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a>&lt;UInt, R&gt; &amp;<em>idx2</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic5Index7projectERK5IndexI4UInt1RER5IndexI4UInt1RE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the projection of this index on to the dimensions specified: idx2[k] = (*this)[dims[k]], for k in [0..R). </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dims</span></code>: [Index&lt;UInt, R&gt;] the dimensions to project onto </li>
<li><code class="docutils literal"><span class="pre">idx2</span></code>: [Index&lt;Uint, R&gt;] the projection of this index </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;UInt <em>R</em>, UInt <em>R2</em>&gt;</dt>
<dt id="_CPPv2NK5nupic5Index5embedERK5IndexI4UInt1RER5IndexI4UInt2R2E">
<span id="nupic::Index::embed__Index:UInt.R:CR.Index:UInt.R2:RC"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1a9e1de1f2b0af736bed3a6f772514b8fc"></span>void <code class="descname">embed</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a>&lt;UInt, R&gt; &amp;<em>dims</em>, <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a>&lt;UInt, R2&gt; &amp;<em>idx2</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic5Index5embedERK5IndexI4UInt1RER5IndexI4UInt2R2E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Embeds the current index into an index of higher dimension: idx2[dims[k]] = (*this)[k], for k in [0..R). </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dims</span></code>: [Index&lt;Uint, R&gt;] the dimensions to embed into </li>
<li><code class="docutils literal"><span class="pre">idx</span></code>: [Index&lt;Uint, R2&gt;] the embedding of this index </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic5Index7permuteERK5IndexR5Index">
<span id="nupic::Index::permute__IndexCR.IndexRC"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1a2874977b91e23cba2010078e1cff7179"></span>void <code class="descname">permute</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>ind</em>, <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>perm</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic5Index7permuteERK5IndexR5Index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Permutes this index according to the order specified in ind. </p>
<p>Examples: [1 2 3 4 5] becomes [2 3 4 5 1] with ind = [1 2 3 4 0] [1 2 3] becomes [3 1 2] with ind = [2 1 0]</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">ind</span></code>: [Index&lt;UInt, NDims&gt;] the new order </li>
<li><code class="docutils literal"><span class="pre">perm</span></code>: [Index&lt;UInt, NDims&gt;] the resulting permutation </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic5Index15findPermutationER5IndexRK5Index">
<span id="nupic::Index::findPermutation__IndexR.IndexCRC"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1a27786bcae28df194f1ad0e4174e4aa85"></span>void <code class="descname">findPermutation</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>ind</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>perm</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic5Index15findPermutationER5IndexRK5Index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the permutation that transforms this index into perm. </p>
<p>If this index is [1 2 3 4 5] and perm is [2 3 4 5 1], the permutation is [1 2 3 4 0] Slow: O(NDims^2) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic5Index7hasZeroEv">
<span id="nupic::Index::hasZeroC"></span><span class="target" id="nupic.coreclassnupic_1_1_index_1aebfe0ed7336c744253969056e32e60dc"></span>bool <code class="descname">hasZero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic5Index7hasZeroEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether any of the values in this index is a zero. </p>
<p>(That is, the &#8220;index&#8221; cannot be used to describe the dimensions of a tensor). </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv2IEN5nupic5IndexI4UInt5NDimsE2i_E">
template&lt;&gt;<br /><span class="target" id="nupic.coreclassnupic_1_1_index_1adaf22b6fb92a6cedfb0e0f340d392178"></span>UInt <code class="descname">i_</code>[NDims]<a class="headerlink" href="#_CPPv2IEN5nupic5IndexI4UInt5NDimsE2i_E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Streaming operator (for debugging). </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="nearestneighbor">
<h2>NearestNeighbor<a class="headerlink" href="#nearestneighbor" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt>
<span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor"></span><em class="property">template </em>&lt;<em class="property">typename</em> T&gt;</dt>
<dt id="_CPPv2N5nupic15NearestNeighborE">
<span id="nupic::NearestNeighbor"></span><em class="property">class </em><code class="descclassname">nupic::</code><code class="descname">NearestNeighbor</code><a class="headerlink" href="#_CPPv2N5nupic15NearestNeighborE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inherits from T</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N5nupic15NearestNeighbor15NearestNeighborE9size_type9size_type">
<span id="nupic::NearestNeighbor::NearestNeighbor__size_type.size_type"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a96fd6cb5d6e3cfe494939455a8cf548d"></span><code class="descname">NearestNeighbor</code><span class="sig-paren">(</span>size_type <em>nrows</em>, size_type <em>ncols</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic15NearestNeighbor15NearestNeighborE9size_type9size_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor with a number of columns and a hint for the number of rows. </p>
<p>The SparseMatrix is empty.</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>nrows &lt; 0 (check) </li>
<li>ncols &lt; 0 (check) </li>
<li>Not enough memory (error) </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">nrows</span></code>: [size_type &gt;= 0] number of rows </li>
<li><code class="docutils literal"><span class="pre">ncols</span></code>: [size_type &gt;= 0] number of columns</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator&gt;</dt>
<dt id="_CPPv2N5nupic15NearestNeighbor15NearestNeighborE9size_type9size_type13InputIterator">
<span id="nupic::NearestNeighbor::NearestNeighbor__size_type.size_type.InputIterator"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a0a8934f0f623bee7a834c6725ad8c855"></span><code class="descname">NearestNeighbor</code><span class="sig-paren">(</span>size_type <em>nrows</em>, size_type <em>ncols</em>, InputIterator <em>dense</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic15NearestNeighbor15NearestNeighborE9size_type9size_type13InputIterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor from a dense matrix passed as an array of value_type. </p>
<p>Uses the values in mat to initialize the SparseMatrix.</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>nrows &lt;= 0 (check) </li>
<li>ncols &lt;= 0 (check) </li>
<li>mat == NULL (check) </li>
<li>NULL pointer in mat (check) </li>
<li>Not enough memory (error) </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">nrows</span></code>: [size_type &gt;= 0] number of rows </li>
<li><code class="docutils literal"><span class="pre">ncols</span></code>: [size_type &gt;= 0] number of columns </li>
<li><code class="docutils literal"><span class="pre">dense</span></code>: [value_type** != NULL] initial array of values</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic15NearestNeighbor15NearestNeighborERNSt7istreamE">
<span id="nupic::NearestNeighbor::NearestNeighbor__isR"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a61c51fa62bead131f2066863eacaf046"></span><code class="descname">NearestNeighbor</code><span class="sig-paren">(</span>std::istream &amp;<em>inStream</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic15NearestNeighbor15NearestNeighborERNSt7istreamE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor from a stream in CSR format (don&#8217;t forget number of bytes after &#8216;csr&#8217; tag!). </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic15NearestNeighbor15NearestNeighborERK15NearestNeighbor">
<span id="nupic::NearestNeighbor::NearestNeighbor__NearestNeighborCR"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a1c9afc9feb242c9f178f6353f0101f21"></span><code class="descname">NearestNeighbor</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic15NearestNeighbor15NearestNeighborE9size_type9size_type" title="nupic::NearestNeighbor::NearestNeighbor">NearestNeighbor</a> &amp;<em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic15NearestNeighbor15NearestNeighborERK15NearestNeighbor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
<p>TODO copy part of a matrix?</p>
<p>Copies the given NearestNeighbor into this one. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic15NearestNeighboraSERK15NearestNeighbor">
<span id="nupic::NearestNeighbor::assign-operator__NearestNeighborCR"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1aaaf12ccb7e81cc61a58488f8296573fa"></span><a class="reference internal" href="#_CPPv2N5nupic15NearestNeighborE" title="nupic::NearestNeighbor">NearestNeighbor</a> &amp;<code class="descname">operator=</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic15NearestNeighborE" title="nupic::NearestNeighbor">NearestNeighbor</a> &amp;<em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic15NearestNeighboraSERK15NearestNeighbor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assignment operator. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15NearestNeighbor9rowL0DistE9size_type13InputIterator">
<span id="nupic::NearestNeighbor::rowL0Dist__size_type.InputIteratorC"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a0a2390aeb88cfd1c6d5fe3033b556db0"></span>value_type <code class="descname">rowL0Dist</code><span class="sig-paren">(</span>size_type <em>row</em>, InputIterator <em>x</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15NearestNeighbor9rowL0DistE9size_type13InputIterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the distance between vector x and a given row of this NearestNeighbor, using the L0 (Hamming) distance: </p>
<p>dist(row, x) = sum(| row[i] - x[i] | &gt; epsilon)</p>
<p>Computations are performed on the non-zeros only.</p>
<p>Non-mutating, O(nnzr)</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>row &lt; 0 || row &gt;= nrows (check) </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">row</span></code>: [0 &lt;= size_type &lt; nrows] index of row to compute distance from </li>
<li><code class="docutils literal"><span class="pre">x</span></code>: [InputIterator&lt;value_type&gt;] x vector </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">[value_type]</span></code>: distance from x to row of index &#8216;row&#8217;</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15NearestNeighbor9rowL1DistE9size_type13InputIterator">
<span id="nupic::NearestNeighbor::rowL1Dist__size_type.InputIteratorC"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a09c6e595ea3e3bf7616e8281f6ddd4b7"></span>value_type <code class="descname">rowL1Dist</code><span class="sig-paren">(</span>size_type <em>row</em>, InputIterator <em>x</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15NearestNeighbor9rowL1DistE9size_type13InputIterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the distance between vector x and a given row of this NearestNeighbor, using the L1 (Manhattan) distance: </p>
<p>dist(row, x) = sum(| row[i] - x[i] |)</p>
<p>Computations are performed on the non-zeros only.</p>
<p>Non-mutating, O(nnzr)</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>row &lt; 0 || row &gt;= nrows (check) </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">row</span></code>: [0 &lt;= size_type &lt; nrows] index of row to compute distance from </li>
<li><code class="docutils literal"><span class="pre">x</span></code>: [InputIterator&lt;value_type&gt;] x vector </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">[value_type]</span></code>: distance from x to row of index &#8216;row&#8217;</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15NearestNeighbor9rowL2DistE9size_type13InputIteratorb">
<span id="nupic::NearestNeighbor::rowL2Dist__size_type.InputIterator.bC"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a26b5f9abf333e953c40cc8723133961d"></span>value_type <code class="descname">rowL2Dist</code><span class="sig-paren">(</span>size_type <em>row</em>, InputIterator <em>x</em>, bool <em>take_root</em> = false<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15NearestNeighbor9rowL2DistE9size_type13InputIteratorb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the distance between vector x and a given row of this NearestNeighbor, using the Euclidean distance: </p>
<p>dist(row, x) = [ sum((row[i] - x[i])^2) ] ^ 1/2</p>
<p>Computations are performed on the non-zeros only. The square root is optional, controlled by parameter take_root.</p>
<p>Non-mutating, O(ncols + nnzr)</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>row &lt; 0 || row &gt;= nrows (check) </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">row</span></code>: [0 &lt;= size_type &lt; nrows] index of row to compute distance from </li>
<li><code class="docutils literal"><span class="pre">x</span></code>: [InputIterator&lt;value_type&gt;] vector of the squared distances to x </li>
<li><code class="docutils literal"><span class="pre">take_root</span></code>: [bool (false)] whether to return the square root of the distance or the exact value (the square root of the sum of the sqaures). Default is to return the square of the distance. </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">[value_type]</span></code>: distance from x to row of index &#8216;row&#8217;</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15NearestNeighbor11rowLMaxDistE9size_type13InputIterator">
<span id="nupic::NearestNeighbor::rowLMaxDist__size_type.InputIteratorC"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a18846eb1f6d779c3c38eb16153a9db87"></span>value_type <code class="descname">rowLMaxDist</code><span class="sig-paren">(</span>size_type <em>row</em>, InputIterator <em>x</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15NearestNeighbor11rowLMaxDistE9size_type13InputIterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the distance between vector x and a given row of this NearestNeighbor, using the Lmax distance: </p>
<p>dist(row, x) = max(| row[i] - x[i] |)</p>
<p>Computations are performed on the non-zeros only.</p>
<p>Non-mutating, O(nnzr)</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>row &lt; 0 || row &gt;= nrows (check) </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">row</span></code>: [0 &lt;= size_type &lt; nrows] index of row to compute distance from </li>
<li><code class="docutils literal"><span class="pre">x</span></code>: [InputIterator&lt;value_type&gt;] x vector </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">[value_type]</span></code>: distance from x to row of index &#8216;row&#8217;</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15NearestNeighbor9rowLpDistE10value_type9size_type13InputIteratorb">
<span id="nupic::NearestNeighbor::rowLpDist__value_type.size_type.InputIterator.bC"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a38e3e81a44fa2660b8e3e32b598520bd"></span>value_type <code class="descname">rowLpDist</code><span class="sig-paren">(</span>value_type <em>p</em>, size_type <em>row</em>, InputIterator <em>x</em>, bool <em>take_root</em> = false<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15NearestNeighbor9rowLpDistE10value_type9size_type13InputIteratorb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the distance between vector x and a given row of this NearestNeighbor, using the Lp distance: </p>
<p>dist(row, x) = [ sum(|row[i] - x[i]|^p) ] ^ 1/p</p>
<p>Computations are performed on the non-zeros only. The square root is optional, controlled by parameter take_root.</p>
<p>Non-mutating.</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>row &lt; 0 || row &gt;= nrows (check) </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">row</span></code>: [0 &lt;= size_type &lt; nrows] index of row to compute distance from </li>
<li><code class="docutils literal"><span class="pre">x</span></code>: [InputIterator&lt;value_type&gt;] vector of the squared distances to x </li>
<li><code class="docutils literal"><span class="pre">take_root</span></code>: [bool (false)] whether to return the p-th power of the distance or the exact value (the p-th root of the sum of the p-powers). Default is to return the p-th power of the distance. </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">[value_type]</span></code>: distance from x to row of index &#8216;row&#8217;</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator, <em class="property">typename</em> OutputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15NearestNeighbor6L0DistE13InputIterator14OutputIterator">
<span id="nupic::NearestNeighbor::L0Dist__InputIterator.OutputIteratorC"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a724cdf28d96b8ffd7041d212716fb4a4"></span>void <code class="descname">L0Dist</code><span class="sig-paren">(</span>InputIterator <em>x</em>, OutputIterator <em>y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15NearestNeighbor6L0DistE13InputIterator14OutputIterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the distance between vector x and all the rows of this NearestNeighbor, using the L0 (Hamming) distance: </p>
<p>dist(row, x) = sum(| row[i] - x[i] | &gt; Epsilon)</p>
<p>Computations are performed on the non-zeros only.</p>
<p>Non-mutating, O(nnzr)</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>None </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">x</span></code>: [InputIterator&lt;value_type&gt;] x vector </li>
<li><code class="docutils literal"><span class="pre">y</span></code>: [OutputIterator&lt;value_type&gt;] vector of distances of x to each row</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator, <em class="property">typename</em> OutputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15NearestNeighbor6L1DistE13InputIterator14OutputIterator">
<span id="nupic::NearestNeighbor::L1Dist__InputIterator.OutputIteratorC"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1ac517400954e4679f0444e67eb26e189d"></span>void <code class="descname">L1Dist</code><span class="sig-paren">(</span>InputIterator <em>x</em>, OutputIterator <em>y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15NearestNeighbor6L1DistE13InputIterator14OutputIterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the distance between vector x and all the rows of this NearestNeighbor, using the L1 (Manhattan) distance: </p>
<p>dist(row, x) = sum(| row[i] - x[i] |)</p>
<p>Computations are performed on the non-zeros only.</p>
<p>Non-mutating, O(nnzr)</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>None </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">x</span></code>: [InputIterator&lt;value_type&gt;] x vector </li>
<li><code class="docutils literal"><span class="pre">y</span></code>: [OutputIterator&lt;value_type&gt;] vector of distances of x to each row</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator, <em class="property">typename</em> OutputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15NearestNeighbor6L2DistE13InputIterator14OutputIteratorb">
<span id="nupic::NearestNeighbor::L2Dist__InputIterator.OutputIterator.bC"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a33b2722e088298fad325a5c0b8ef1e86"></span>void <code class="descname">L2Dist</code><span class="sig-paren">(</span>InputIterator <em>x</em>, OutputIterator <em>y</em>, bool <em>take_root</em> = false<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15NearestNeighbor6L2DistE13InputIterator14OutputIteratorb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the Euclidean distance between vector x and each row of this NearestNeighbor. </p>
<p>Non-mutating, O(nnz)</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>None </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">x</span></code>: [InputIterator&lt;value_type&gt;] vector to compute the distance from </li>
<li><code class="docutils literal"><span class="pre">y</span></code>: [OutputIterator&lt;value_type&gt;] vector of the distances to x </li>
<li><code class="docutils literal"><span class="pre">take_root</span></code>: [bool (false)] whether to return the square root of the distances or their exact value (the square root of the sum of the squares). Default is to return the square of the distances.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator, <em class="property">typename</em> OutputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15NearestNeighbor8LMaxDistE13InputIterator14OutputIterator">
<span id="nupic::NearestNeighbor::LMaxDist__InputIterator.OutputIteratorC"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1aff913df0af657f176cd5ba944bd84136"></span>void <code class="descname">LMaxDist</code><span class="sig-paren">(</span>InputIterator <em>x</em>, OutputIterator <em>y</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15NearestNeighbor8LMaxDistE13InputIterator14OutputIterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the Lmax distance between vector x and each row of this NearestNeighbor. </p>
<p>Non-mutating, O(nrows*ncols)</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>None </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">x</span></code>: [InputIterator&lt;value_type&gt;] vector to compute the distance from </li>
<li><code class="docutils literal"><span class="pre">y</span></code>: [OutputIterator&lt;value_type&gt;] vector of the distances to x</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator, <em class="property">typename</em> OutputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15NearestNeighbor6LpDistE10value_type13InputIterator14OutputIteratorb">
<span id="nupic::NearestNeighbor::LpDist__value_type.InputIterator.OutputIterator.bC"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1addde584bc849afd2c6644336ab471776"></span>void <code class="descname">LpDist</code><span class="sig-paren">(</span>value_type <em>p</em>, InputIterator <em>x</em>, OutputIterator <em>y</em>, bool <em>take_root</em> = false<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15NearestNeighbor6LpDistE10value_type13InputIterator14OutputIteratorb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the p-th power of the Lp distance between vector x and each row of this NearestNeighbor. </p>
<p>Puts the result in vector y. If take_root is true, we take the p-th root of the sums, if not, y will contain the sum of the p-th powers only.</p>
<p>Non-mutating, O(nnz)</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>None </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">x</span></code>: [InputIterator&lt;value_type&gt;] vector to compute the distance from </li>
<li><code class="docutils literal"><span class="pre">y</span></code>: [OutputIterator&lt;value_type&gt;] vector of the squared distances to x </li>
<li><code class="docutils literal"><span class="pre">take_root</span></code>: [bool (false)] whether to return the p-th power of the distances or their exact value (the p-th root of the sum of the p-powers). Default is to return the p-th power of the distances.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator, <em class="property">typename</em> OutputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15NearestNeighbor9L0NearestE13InputIterator14OutputIterator9size_type">
<span id="nupic::NearestNeighbor::L0Nearest__InputIterator.OutputIterator.size_typeC"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a405632ecc5d85eff736217379bc754a5"></span>void <code class="descname">L0Nearest</code><span class="sig-paren">(</span>InputIterator <em>x</em>, OutputIterator <em>nn</em>, size_type <em>k</em> = 1<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15NearestNeighbor9L0NearestE13InputIterator14OutputIterator9size_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the row nearest to x, where nearest is defined as the row which has the smallest L0 (Hamming) distance to x. </p>
<p>If k &gt; 1, finds the k nearest rows to x.</p>
<p>Non-mutating, O(nnz) + complexity of partial sort up to k if k &gt; 1.</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>If k &lt; 1. </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">x</span></code>: [InputIterator&lt;value_type&gt;] vector to compute the distance from </li>
<li><code class="docutils literal"><span class="pre">nn</span></code>: [OutputIterator] the indices and distances of the nearest rows (pairs) </li>
<li><code class="docutils literal"><span class="pre">k</span></code>: [size_type &gt; 0, (1)] the number of nearest rows to retrieve</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator, <em class="property">typename</em> OutputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15NearestNeighbor9L1NearestE13InputIterator14OutputIterator9size_type">
<span id="nupic::NearestNeighbor::L1Nearest__InputIterator.OutputIterator.size_typeC"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a9d56adb5223a1d5cc76f729b32e06cd5"></span>void <code class="descname">L1Nearest</code><span class="sig-paren">(</span>InputIterator <em>x</em>, OutputIterator <em>nn</em>, size_type <em>k</em> = 1<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15NearestNeighbor9L1NearestE13InputIterator14OutputIterator9size_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the row nearest to x, where nearest is defined as the row which has the smallest L1 (Manhattan) distance to x. </p>
<p>If k &gt; 1, finds the k nearest rows to x.</p>
<p>Non-mutating, O(nnz) + complexity of partial sort up to k if k &gt; 1.</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>If k &lt; 1. </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">x</span></code>: [InputIterator&lt;value_type&gt;] vector to compute the distance from </li>
<li><code class="docutils literal"><span class="pre">nn</span></code>: [OutputIterator] the indices and distances of the nearest rows (pairs) </li>
<li><code class="docutils literal"><span class="pre">k</span></code>: [size_type &gt; 0, (1)] the number of nearest rows to retrieve</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator, <em class="property">typename</em> OutputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15NearestNeighbor9L2NearestE13InputIterator14OutputIterator9size_typeb">
<span id="nupic::NearestNeighbor::L2Nearest__InputIterator.OutputIterator.size_type.bC"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a383d682c6e096413b892205fb8873695"></span>void <code class="descname">L2Nearest</code><span class="sig-paren">(</span>InputIterator <em>x</em>, OutputIterator <em>nn</em>, size_type <em>k</em> = 1, bool <em>take_root</em> = false<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15NearestNeighbor9L2NearestE13InputIterator14OutputIterator9size_typeb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the row nearest to x, where nearest is defined as the row which has the smallest L2 (Euclidean) distance to x. </p>
<p>If k &gt; 1, finds the k nearest rows to x.</p>
<p>Non-mutating, O(nnz) + complexity of partial sort up to k if k &gt; 1.</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>If k &lt; 1. </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">x</span></code>: [InputIterator&lt;value_type&gt;] vector to compute the distance from </li>
<li><code class="docutils literal"><span class="pre">nn</span></code>: [OutputIterator] the indices and distances of the nearest rows (pairs) </li>
<li><code class="docutils literal"><span class="pre">k</span></code>: [size_type &gt; 0, (1)] the number of nearest rows to retrieve </li>
<li><code class="docutils literal"><span class="pre">take_root</span></code>: [bool (false)] whether to return the square root of the distances or their exact value (the square root of the sum of the squares). Default is to return the square of the distances.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator, <em class="property">typename</em> OutputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15NearestNeighbor11LMaxNearestE13InputIterator14OutputIterator9size_type">
<span id="nupic::NearestNeighbor::LMaxNearest__InputIterator.OutputIterator.size_typeC"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a9736787ce4e55849082157803dc7b77f"></span>void <code class="descname">LMaxNearest</code><span class="sig-paren">(</span>InputIterator <em>x</em>, OutputIterator <em>nn</em>, size_type <em>k</em> = 1<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15NearestNeighbor11LMaxNearestE13InputIterator14OutputIterator9size_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the row nearest to x, where nearest is defined as the row which has the smallest Lmax distance to x. </p>
<p>If k &gt; 1, finds the k nearest rows to x.</p>
<p>Non-mutating, O(nnz) + complexity of partial sort up to k if k &gt; 1.</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>If k &lt; 1. </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">x</span></code>: [InputIterator&lt;value_type&gt;] vector to compute the distance from </li>
<li><code class="docutils literal"><span class="pre">nn</span></code>: [OutputIterator] the indices and distances of the nearest rows (pairs) </li>
<li><code class="docutils literal"><span class="pre">k</span></code>: [size_type &gt; 0, (1)] the number of nearest rows to retrieve</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator, <em class="property">typename</em> OutputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15NearestNeighbor9LpNearestE10value_type13InputIterator14OutputIterator9size_typeb">
<span id="nupic::NearestNeighbor::LpNearest__value_type.InputIterator.OutputIterator.size_type.bC"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a1bb8e55d25795e5b4b73e1d86123ba32"></span>void <code class="descname">LpNearest</code><span class="sig-paren">(</span>value_type <em>p</em>, InputIterator <em>x</em>, OutputIterator <em>nn</em>, size_type <em>k</em> = 1, bool <em>take_root</em> = false<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15NearestNeighbor9LpNearestE10value_type13InputIterator14OutputIterator9size_typeb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the row nearest to x, where nearest is defined as the row which has the smallest Lp distance to x. </p>
<p>If k &gt; 1, finds the k nearest rows to x.</p>
<p>Non-mutating, O(nnz) + complexity of partial sort up to k if k &gt; 1.</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>If p &lt; 0. </li>
<li>If k &lt; 1. </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">x</span></code>: [InputIterator&lt;value_type&gt;] vector to compute the distance from </li>
<li><code class="docutils literal"><span class="pre">nn</span></code>: [OutputIterator1] the indices and distances of the nearest rows (pairs) </li>
<li><code class="docutils literal"><span class="pre">k</span></code>: [size_type &gt; 0, (1)] the number of nearest rows to retrieve </li>
<li><code class="docutils literal"><span class="pre">take_root</span></code>: [bool (false)] whether to return the p-th power of the distances or their exact value (the p-th root of the sum of the p-powers). Default is to return the p-th power of the distances.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15NearestNeighbor10dotNearestE13InputIterator">
<span id="nupic::NearestNeighbor::dotNearest__InputIteratorC"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a34ed40b56294f06375cdaf2492c8d5de"></span>std::pair&lt;size_type, value_type&gt; <code class="descname">dotNearest</code><span class="sig-paren">(</span>InputIterator <em>x</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15NearestNeighbor10dotNearestE13InputIterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the &#8220;nearest-dot&#8221; distance between vector x and each row in this NearestNeighbor. </p>
<p>Returns the index of the row that maximizes the dot product as well as the value of this dot-product.</p>
<p>Note that this equivalent to L2Nearest if all the vectors are normalized.</p>
<p>Non-mutating, O(nnz)</p>
<p><strong>Exceptions:</strong> <ul class="simple">
<li>None </li>
</ul>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">x</span></code>: [InputIterator&lt;value_type&gt;] vector to compute the distance from </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">[std::pair&lt;size_type</span><span class="pre">value_type&gt;]</span></code>: index of the row nearest to x, and value of the distance between x and that row</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator, <em class="property">typename</em> OutputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15NearestNeighbor13projLpNearestE10value_type13InputIterator14OutputIterator9size_typeb">
<span id="nupic::NearestNeighbor::projLpNearest__value_type.InputIterator.OutputIterator.size_type.bC"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a74a5ac81d8160fbbab5ee761b371b354"></span>void <code class="descname">projLpNearest</code><span class="sig-paren">(</span>value_type <em>p</em>, InputIterator <em>x</em>, OutputIterator <em>nn</em>, size_type <em>k</em> = 1, bool <em>take_root</em> = false<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15NearestNeighbor13projLpNearestE10value_type13InputIterator14OutputIterator9size_typeb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the k-nearest neighbors to x, ignoring the zeros of each vector stored in this matrix. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv2N5nupic15NearestNeighbor7stddev_E">
<span id="nupic::NearestNeighbor::stddev___std::vector:value_type:"></span><span class="target" id="nupic.coreclassnupic_1_1_nearest_neighbor_1a35c95f568d29891d5a1af5d296b02fed"></span>std::vector&lt;value_type&gt; <code class="descname">stddev_</code><a class="headerlink" href="#_CPPv2N5nupic15NearestNeighbor7stddev_E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>EXPERIMENTAL This method computes the std dev of each component of the vectors, and scales them by that standard deviation before computing the norms. </p>
<p>Distance values are distorted by the standard deviation. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="segmentmatrixadapter">
<h2>SegmentMatrixAdapter<a class="headerlink" href="#segmentmatrixadapter" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt>
<span class="target" id="nupic.coreclassnupic_1_1_segment_matrix_adapter"></span><em class="property">template </em>&lt;typename <em>Matrix</em>&gt;</dt>
<dt id="_CPPv2N5nupic20SegmentMatrixAdapterE">
<span id="nupic::SegmentMatrixAdapter"></span><em class="property">class </em><code class="descclassname">nupic::</code><code class="descname">SegmentMatrixAdapter</code><a class="headerlink" href="#_CPPv2N5nupic20SegmentMatrixAdapterE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A data structure that stores dendrite segments as rows in a matrix. </p>
<p>The matrix itself is part of this class&#8217;s public API. This class stores the segments for each cell, and it can get the cell for each segment.</p>
<p>This class is focused on Python consumers. C++ consumers could easily accomplish all of this directly with a matrix class, but Python consumers need a fast way of doing segment reads and writes in batches. This class makes it possible to add rows in batch, maintaining mappings between cells and segments, and providing batch lookups on those mappings. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2NK5nupic20SegmentMatrixAdapter6nCellsEv">
<span id="nupic::SegmentMatrixAdapter::nCellsC"></span><span class="target" id="nupic.coreclassnupic_1_1_segment_matrix_adapter_1a97074efbde229a214c627793d17d5077"></span>size_type <code class="descname">nCells</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic20SegmentMatrixAdapter6nCellsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of cells. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic20SegmentMatrixAdapter9nSegmentsEv">
<span id="nupic::SegmentMatrixAdapter::nSegmentsC"></span><span class="target" id="nupic.coreclassnupic_1_1_segment_matrix_adapter_1aebc5d02d9643593011d7996b94ead70d"></span>size_type <code class="descname">nSegments</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic20SegmentMatrixAdapter9nSegmentsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of segments. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic20SegmentMatrixAdapter13createSegmentE9size_type">
<span id="nupic::SegmentMatrixAdapter::createSegment__size_type"></span><span class="target" id="nupic.coreclassnupic_1_1_segment_matrix_adapter_1a8c5f66370aa0787ccaad7dce4a847979"></span>size_type <code class="descname">createSegment</code><span class="sig-paren">(</span>size_type <em>cell</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic20SegmentMatrixAdapter13createSegmentE9size_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a segment. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">cell</span></code>: The cell that gets a new segment </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator, <em class="property">typename</em> OutputIterator&gt;</dt>
<dt id="_CPPv2N5nupic20SegmentMatrixAdapter14createSegmentsE13InputIterator13InputIterator14OutputIterator">
<span id="nupic::SegmentMatrixAdapter::createSegments__InputIterator.InputIterator.OutputIterator"></span><span class="target" id="nupic.coreclassnupic_1_1_segment_matrix_adapter_1a0c7a3f871e5969bb4ed87f72aa6154e5"></span>void <code class="descname">createSegments</code><span class="sig-paren">(</span>InputIterator <em>cells_begin</em>, InputIterator <em>cells_end</em>, OutputIterator <em>segments_begin</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic20SegmentMatrixAdapter14createSegmentsE13InputIterator13InputIterator14OutputIterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create one segment on each of the specified cells. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">cells</span></code>: The cells that each get a new segment</li>
<li><code class="docutils literal"><span class="pre">segments</span></code>: An output array with the same size as &#8216;cells&#8217; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic20SegmentMatrixAdapter14destroySegmentE9size_type">
<span id="nupic::SegmentMatrixAdapter::destroySegment__size_type"></span><span class="target" id="nupic.coreclassnupic_1_1_segment_matrix_adapter_1a6a7107763d6d033c7d1f3c377387c037"></span>void <code class="descname">destroySegment</code><span class="sig-paren">(</span>size_type <em>segment</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic20SegmentMatrixAdapter14destroySegmentE9size_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy a segment. </p>
<p>Remove it from its cell and remove all of its synapses in the Matrix.</p>
<p>This doesn&#8217;t remove the segment&#8217;s row from the Matrix, so the other segments&#8217; row numbers are unaffected.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">segment</span></code>: The segment to destroy </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator&gt;</dt>
<dt id="_CPPv2N5nupic20SegmentMatrixAdapter15destroySegmentsE13InputIterator13InputIterator">
<span id="nupic::SegmentMatrixAdapter::destroySegments__InputIterator.InputIterator"></span><span class="target" id="nupic.coreclassnupic_1_1_segment_matrix_adapter_1a32a6ce49f1de0c22476ed2a608a7b2d0"></span>void <code class="descname">destroySegments</code><span class="sig-paren">(</span>InputIterator <em>segments_begin</em>, InputIterator <em>segments_end</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic20SegmentMatrixAdapter15destroySegmentsE13InputIterator13InputIterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy multiple segments. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">segments</span></code>: The segments to destroy </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator, <em class="property">typename</em> OutputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic20SegmentMatrixAdapter16getSegmentCountsE13InputIterator13InputIterator14OutputIterator">
<span id="nupic::SegmentMatrixAdapter::getSegmentCounts__InputIterator.InputIterator.OutputIteratorC"></span><span class="target" id="nupic.coreclassnupic_1_1_segment_matrix_adapter_1ae18ef038c7d0b858cd59b204c52f702d"></span>void <code class="descname">getSegmentCounts</code><span class="sig-paren">(</span>InputIterator <em>cells_begin</em>, InputIterator <em>cells_end</em>, OutputIterator <em>counts_begin</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic20SegmentMatrixAdapter16getSegmentCountsE13InputIterator13InputIterator14OutputIterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of segments on each of the provided cells. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">cells</span></code>: The cells to check</li>
<li><code class="docutils literal"><span class="pre">counts</span></code>: <a class="reference internal" href="network-io.html#nupic.coreclassnupic_1_1_output"><span class="std std-ref">Output</span></a> array with the same length as &#8216;cells&#8217; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic20SegmentMatrixAdapter18getSegmentsForCellE9size_type">
<span id="nupic::SegmentMatrixAdapter::getSegmentsForCell__size_typeC"></span><span class="target" id="nupic.coreclassnupic_1_1_segment_matrix_adapter_1aa1879316693a6eb9f6b866e1f36b7d1d"></span><em class="property">const</em> std::vector&lt;size_type&gt; &amp;<code class="descname">getSegmentsForCell</code><span class="sig-paren">(</span>size_type <em>cell</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic20SegmentMatrixAdapter18getSegmentsForCellE9size_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the segments for a cell. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">cell</span></code>: The cell </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic20SegmentMatrixAdapter18sortSegmentsByCellE13InputIterator13InputIterator">
<span id="nupic::SegmentMatrixAdapter::sortSegmentsByCell__InputIterator.InputIteratorC"></span><span class="target" id="nupic.coreclassnupic_1_1_segment_matrix_adapter_1ac19c39c563fae0c140ed2e91b17420ae"></span>void <code class="descname">sortSegmentsByCell</code><span class="sig-paren">(</span>InputIterator <em>segments_begin</em>, InputIterator <em>segments_end</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic20SegmentMatrixAdapter18sortSegmentsByCellE13InputIterator13InputIterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sort an array of segments by cell in increasing order. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">segments</span></code>: The segment array. It&#8217;s sorted in-place. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator1, <em class="property">typename</em> InputIterator2&gt;</dt>
<dt id="_CPPv2NK5nupic20SegmentMatrixAdapter20filterSegmentsByCellE14InputIterator114InputIterator114InputIterator214InputIterator2">
<span id="nupic::SegmentMatrixAdapter::filterSegmentsByCell__InputIterator1.InputIterator1.InputIterator2.InputIterator2C"></span><span class="target" id="nupic.coreclassnupic_1_1_segment_matrix_adapter_1a5625811a5856b90e2b68fe2ef44d3185"></span>std::vector&lt;size_type&gt; <code class="descname">filterSegmentsByCell</code><span class="sig-paren">(</span>InputIterator1 <em>segments_begin</em>, InputIterator1 <em>segments_end</em>, InputIterator2 <em>cells_begin</em>, InputIterator2 <em>cells_end</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic20SegmentMatrixAdapter20filterSegmentsByCellE14InputIterator114InputIterator114InputIterator214InputIterator2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the subset of segments that are on the provided cells. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">segments</span></code>: The segments to filter. Must be sorted by cell.</li>
<li><code class="docutils literal"><span class="pre">cells</span></code>: The cells whose segments we want to keep. Must be sorted. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator, <em class="property">typename</em> OutputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic20SegmentMatrixAdapter18mapSegmentsToCellsE13InputIterator13InputIterator14OutputIterator">
<span id="nupic::SegmentMatrixAdapter::mapSegmentsToCells__InputIterator.InputIterator.OutputIteratorC"></span><span class="target" id="nupic.coreclassnupic_1_1_segment_matrix_adapter_1a63528f8b889f92bf83bb4b6ebbddc0c4"></span>void <code class="descname">mapSegmentsToCells</code><span class="sig-paren">(</span>InputIterator <em>segments_begin</em>, InputIterator <em>segments_end</em>, OutputIterator <em>cells_begin</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic20SegmentMatrixAdapter18mapSegmentsToCellsE13InputIterator13InputIterator14OutputIterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the cell for each provided segment. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">segments</span></code>: The segments to query</li>
<li><code class="docutils literal"><span class="pre">cells</span></code>: <a class="reference internal" href="network-io.html#nupic.coreclassnupic_1_1_output"><span class="std std-ref">Output</span></a> array with the same length as &#8216;segments&#8217; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv2N5nupic20SegmentMatrixAdapter6matrixE">
<span id="nupic::SegmentMatrixAdapter::matrix__Matrix"></span><span class="target" id="nupic.coreclassnupic_1_1_segment_matrix_adapter_1aaabce01692959a7765577317b28758e0"></span>Matrix <code class="descname">matrix</code><a class="headerlink" href="#_CPPv2N5nupic20SegmentMatrixAdapter6matrixE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The underlying Matrix. </p>
<p>Each row is a segment.</p>
<p>Don&#8217;t add or remove rows directly. Use createSegment / destroySegment. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="set">
<h2>Set<a class="headerlink" href="#set" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt>
<span class="target" id="nupic.coreclassnupic_1_1_set"></span><em class="property">template </em>&lt;<em class="property">typename</em> T = size_t, <em class="property">typename</em> T_byte = unsigned char&gt;</dt>
<dt id="_CPPv2N5nupic3SetE">
<span id="nupic::Set"></span><em class="property">class </em><code class="descclassname">nupic::</code><code class="descname">Set</code><a class="headerlink" href="#_CPPv2N5nupic3SetE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N5nupic3Set3SetE1T1TP1T">
<span id="nupic::Set::Set__T.T.TP"></span><span class="target" id="nupic.coreclassnupic_1_1_set_1ad665e96e41777fd571598bb030d9d6c6"></span><code class="descname">Set</code><span class="sig-paren">(</span>T <em>_m</em>, T <em>_n</em>, T *<em>ss</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic3Set3SetE1T1TP1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs from a list of n element indices ss, each element being in the interval [0,m[. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic3Set12intersectionE1TP1TP1T">
<span id="nupic::Set::intersection__T.TP.TPC"></span><span class="target" id="nupic.coreclassnupic_1_1_set_1a44c2a2dab298ec09ef628479d39e2312"></span>T <code class="descname">intersection</code><span class="sig-paren">(</span>T <em>n2</em>, T *<em>s2</em>, T *<em>r</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic3Set12intersectionE1TP1TP1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the intersection between this and another set (n2, s2). </p>
<p>n2 is the number of element in the second s, s2 is a pointer to the first element, which needs to be stored contiguously. s2 needs to store the indices of the elements: (2,7,11) is the set of those 3 elements. r is the result set, and is also a list of element indices. This method also returns an integer, which is the number of elements in the intersection (so that r can be allocated once, and its first few positions reused over and over again).</p>
<p>NOTE: for best performance, have n2 &lt;&lt; n </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="sparsematrixalgorithms">
<h2>SparseMatrixAlgorithms<a class="headerlink" href="#sparsematrixalgorithms" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithmsE">
<span id="nupic::SparseMatrixAlgorithms"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms"></span><em class="property">struct </em><code class="descclassname">nupic::</code><code class="descname">SparseMatrixAlgorithms</code><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithmsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A collection of algorithms that operate on SparseMatrix. </p>
<p>They are put here instead of directly in the SparseMatrix because they are not as general as the SparseMatrix methods. They are usually tailored for a specific, sometimes experimental, algorithm. This struct is a friend of SparseMatrix, so that it can access iterators on the indices and values of the non-zeros that are not made public in SparseMatrix. In the following methods, template parameter &#8220;SM&#8221; stands for a SparseMatrix type. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms12entropy_rateERK2SM">
<span id="nupic::SparseMatrixAlgorithms::entropy_rate__SMCR"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a0caf8f522515a8a19fc8b28e4761e2ae"></span><em class="property">static</em> SM::value_type <code class="descname">entropy_rate</code><span class="sig-paren">(</span><em class="property">const</em> SM &amp;<em>sm</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms12entropy_rateERK2SM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the entropy rate of a sparse matrix, along the rows or the columns. </p>
<p>This is defined as: sum(-nz[i,j] * log2(nz[i,j]) * sum_of_row[i], for all i,j), i.e. the usual definition of entropy, but weighted by the probability of the rows or column, i.e. the probability of the conditional distributions.</p>
<p>A copy of the matrix passed in is performed, and the copy is normalized to give it the meaning of a joint distribution. This is pretty slow.</p>
<p>TODO:</p>
<p>I don&#8217;t think the matrix needs to be normalized (which means rowwise normalization). You&#8217;ve already computed the &#8220;row sums&#8221;, which are the per-row normalization factor, and you can use this in the entropy calculation. i.e. if n is the norm of a single row and x[i] is the original value and xn[i] = x[i]/n is the normalized value then the partial contribution for that row is:<ul class="simple">
<li>n * sum xn[i] * ln xn[i] = - n * sum x[i]/n * ln x[i]/n = - sum x[i] *( ln x[i] - ln[n]) = sum x[i] ln[n] - sum x[i] ln x[i] = n ln [n] - sum x[i] ln x[i]</li>
</ul>
</p>
<p>In other words, you compute the entropy based on the non-normalized matrix and then add n ln[n] (There may be an error in this calculation, but in any case, I&#8217;m pretty sure you don&#8217;t actually need to normalize the matrix) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM, <em class="property">typename</em> OutputIter&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms14matrix_entropyERK2SM10OutputIter10OutputIter10OutputIter10OutputIterN2SM10value_typeE">
<span id="nupic::SparseMatrixAlgorithms::matrix_entropy__SMCR.OutputIter.OutputIter.OutputIter.OutputIter.SM::value_type"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a5916c87a5cca46fc294d56960690614c"></span><em class="property">static</em> void <code class="descname">matrix_entropy</code><span class="sig-paren">(</span><em class="property">const</em> SM &amp;<em>sm</em>, OutputIter <em>row_out</em>, OutputIter <em>row_out_end</em>, OutputIter <em>col_out</em>, OutputIter <em>col_out_end</em>, <em class="property">typename</em> SM::value_type <em>s</em> = 1.0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms14matrix_entropyERK2SM10OutputIter10OutputIter10OutputIter10OutputIterN2SM10value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes an entropy on a &#8220;smoothed&#8221; SM, for each row and for each column. </p>
<p>Smoothes by simply adding 1 to each count as the entropy is calculated. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM1, <em class="property">typename</em> SM2&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms28aX_plus_bX_elementMultiply_YERKN3SM110value_typeER3SM1RKN3SM110value_typeERK3SM2">
<span id="nupic::SparseMatrixAlgorithms::aX_plus_bX_elementMultiply_Y__SM1::value_typeCR.SM1R.SM1::value_typeCR.SM2CR"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a1d46da5976337d2d1afd16044c6d50ca"></span><em class="property">static</em> void <code class="descname">aX_plus_bX_elementMultiply_Y</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">typename</em> SM1::value_type &amp;<em>a</em>, SM1 &amp;<em>Xoutput</em>, <em class="property">const</em> <em class="property">typename</em> SM1::value_type &amp;<em>b</em>, <em class="property">const</em> SM2 &amp;<em>Y</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms28aX_plus_bX_elementMultiply_YERKN3SM110value_typeER3SM1RKN3SM110value_typeERK3SM2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Multiplies the &#8216;X&#8217; matrix by the constant &#8216;a&#8217;, then adds &#8216;b * X * Y&#8217; to it, in-place. </p>
<p>for row in [0,nrows): for col in [0,ncols): X[row,col] = X[row,col] * (a + b * Y[row,col])</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">a</span></code>: [value_type] a coefficient </li>
<li><code class="docutils literal"><span class="pre">b</span></code>: [value_type] b coefficient </li>
<li><code class="docutils literal"><span class="pre">B</span></code>: [const SparseMatrix&lt;size_type, value_type&gt;] Y matrix </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM, <em class="property">typename</em> InIter1, <em class="property">typename</em> OutIter&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms15kthroot_productERK2SMN2SM9size_typeE7InIter17OutIterRKN2SM10value_typeE">
<span id="nupic::SparseMatrixAlgorithms::kthroot_product__SMCR.SM::size_type.InIter1.OutIter.SM::value_typeCR"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a949d2a7baa6a6615c600fa8ebfcc9166"></span><em class="property">static</em> void <code class="descname">kthroot_product</code><span class="sig-paren">(</span><em class="property">const</em> SM &amp;<em>sm</em>, <em class="property">typename</em> SM::size_type <em>ss</em>, InIter1 <em>x</em>, OutIter <em>y</em>, <em class="property">const</em> <em class="property">typename</em> SM::value_type &amp;<em>min_input</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms15kthroot_productERK2SMN2SM9size_typeE7InIter17OutIterRKN2SM10value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Used to speed up sparse pooler algorithm. </p>
<p>TODO: describe algo. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM, <em class="property">typename</em> InputIterator1, <em class="property">typename</em> InputIterator2&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms18sparseRightVecProdERK2SMN2SM9size_typeEN2SM9size_typeE14InputIterator114InputIterator2">
<span id="nupic::SparseMatrixAlgorithms::sparseRightVecProd__SMCR.SM::size_type.SM::size_type.InputIterator1.InputIterator2"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a0feab00039f5948385bbd7ed03037458"></span><em class="property">static</em> void <code class="descname">sparseRightVecProd</code><span class="sig-paren">(</span><em class="property">const</em> SM &amp;<em>sm</em>, <em class="property">typename</em> SM::size_type <em>x_begin</em>, <em class="property">typename</em> SM::size_type <em>x_end</em>, InputIterator1 <em>x</em>, InputIterator2 <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms18sparseRightVecProdERK2SMN2SM9size_typeEN2SM9size_typeE14InputIterator114InputIterator2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the product of a sparse matrix and a sparse vector on the right. </p>
<p>[x_begin, x_end) is the range of x that contains the non-zeros for x. This function skips multiplying by zeros out of [x_begin, x_end). This is used only in nupic/math_research/shmm.cpp and direct unit testing is missing.</p>
<p>TODO: check if we can&#8217;t remove that and replace by incrementOuterWithNZ </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM, <em class="property">typename</em> InputIterator, <em class="property">typename</em> OutputIterator&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms16smoothVecMaxProdERK2SMN2SM10value_typeE13InputIterator13InputIterator14OutputIterator14OutputIterator">
<span id="nupic::SparseMatrixAlgorithms::smoothVecMaxProd__SMCR.SM::value_type.InputIterator.InputIterator.OutputIterator.OutputIterator"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a5aa1352b4dcb05aeb7256eaa66513ccb"></span><em class="property">static</em> void <code class="descname">smoothVecMaxProd</code><span class="sig-paren">(</span><em class="property">const</em> SM &amp;<em>sm</em>, <em class="property">typename</em> SM::value_type <em>k</em>, InputIterator <em>x</em>, InputIterator <em>x_end</em>, OutputIterator <em>y</em>, OutputIterator <em>y_end</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms16smoothVecMaxProdERK2SMN2SM10value_typeE13InputIterator13InputIterator14OutputIterator14OutputIterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wrapper for iterator-based sparseRightVecProd that takes std::vectors. </p>
<p>TODO: can we remove? Computes a smoothed version of all rows vec max prod, that is:</p>
<p>for row in [0,nrows): y[row] = max((this[row,col] + k) * x[col], for col in [0,ncols)) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM, <em class="property">typename</em> InputIterator, <em class="property">typename</em> OutputIterator&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms19smoothVecArgMaxProdERK2SMN2SM10value_typeE13InputIterator13InputIterator14OutputIterator14OutputIterator">
<span id="nupic::SparseMatrixAlgorithms::smoothVecArgMaxProd__SMCR.SM::value_type.InputIterator.InputIterator.OutputIterator.OutputIterator"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1ad7cabb935267af8fe68f1dad185d56f9"></span><em class="property">static</em> void <code class="descname">smoothVecArgMaxProd</code><span class="sig-paren">(</span><em class="property">const</em> SM &amp;<em>sm</em>, <em class="property">typename</em> SM::value_type <em>k</em>, InputIterator <em>x</em>, InputIterator <em>x_end</em>, OutputIterator <em>y</em>, OutputIterator <em>y_end</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms19smoothVecArgMaxProdERK2SMN2SM10value_typeE13InputIterator13InputIterator14OutputIterator14OutputIterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes a smoothed version of all rows vec arg max prod, that is: </p>
<p>for row in [0,nrows): y[row] = argmax((this[row,col] + k) * x[col], for col in [0,ncols)) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms11addToNZOnlyER2SMdN2SM10value_typeE">
<span id="nupic::SparseMatrixAlgorithms::addToNZOnly__SMR.double.SM::value_type"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a43c1f61f5964be6722c126860fe8f53b"></span><em class="property">static</em> void <code class="descname">addToNZOnly</code><span class="sig-paren">(</span>SM &amp;<em>A</em>, double <em>val</em>, <em class="property">typename</em> SM::value_type <em>minFloor</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms11addToNZOnlyER2SMdN2SM10value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Adds a value to the non-zeros of a SparseMatrix. </p>
<p>If minFloor &gt; 0, values &lt; minFloor are replaced by minFloor. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM, <em class="property">typename</em> U&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms15addToNZDownColsER2SM1U1UN2SM10value_typeE">
<span id="nupic::SparseMatrixAlgorithms::addToNZDownCols__SMR.U.U.SM::value_type"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a8e20883839058ba0eedea7c7a7b995a3"></span><em class="property">static</em> void <code class="descname">addToNZDownCols</code><span class="sig-paren">(</span>SM &amp;<em>A</em>, U <em>begin</em>, U <em>end</em>, <em class="property">typename</em> SM::value_type <em>minFloor</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms15addToNZDownColsER2SM1U1UN2SM10value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Adds vector to non-zeros only, down the columns. </p>
<p>If minFloor is &gt; 0, any element that drop below minFloor are replaced by minFloor. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM, <em class="property">typename</em> U&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms17addToNZAcrossRowsER2SM1U1UN2SM10value_typeE">
<span id="nupic::SparseMatrixAlgorithms::addToNZAcrossRows__SMR.U.U.SM::value_type"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a0df0726d9027ae8d18edd7168ba2813b"></span><em class="property">static</em> void <code class="descname">addToNZAcrossRows</code><span class="sig-paren">(</span>SM &amp;<em>A</em>, U <em>begin</em>, U <em>end</em>, <em class="property">typename</em> SM::value_type <em>minFloor</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms17addToNZAcrossRowsER2SM1U1UN2SM10value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Adds vector to non-zeros only, across the rows. </p>
<p>If minFloor is &gt; 0, any element that drop below minFloor are replaced by minFloor. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms10NZOneMinusER2SM">
<span id="nupic::SparseMatrixAlgorithms::NZOneMinus__SMR"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a0b12179f0f63676c1fde04dfa09241dd"></span><em class="property">static</em> void <code class="descname">NZOneMinus</code><span class="sig-paren">(</span>SM &amp;<em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms10NZOneMinusER2SM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replaces non-zeros by 1 - non-zero value. </p>
<p>This can introduce new zeros, but not any new zero.</p>
<p>TODO: clarify. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms10addNoAllocER2SMRK2SMN2SM10value_typeE">
<span id="nupic::SparseMatrixAlgorithms::addNoAlloc__SMR.SMCR.SM::value_type"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1aaa4b9f748254e755271c6be15ad65f0f"></span><em class="property">static</em> void <code class="descname">addNoAlloc</code><span class="sig-paren">(</span>SM &amp;<em>A</em>, <em class="property">const</em> SM &amp;<em>B</em>, <em class="property">typename</em> SM::value_type <em>minFloor</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms10addNoAllocER2SMRK2SMN2SM10value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Adds the non-zeros of B to the non-zeros of A. </p>
<p>Assumes that everywhere B has a non-zeros, A has a non-zero. Non-zeros of A that don&#8217;t match up with a non-zero of B are unaffected.</p>
<p>[[1 0 2] + [[3 0 0] = [[4 0 2] [0 3 0]] [0 1 0]] [0 4 0]] </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms15subtractNoAllocER2SMRK2SMN2SM10value_typeE">
<span id="nupic::SparseMatrixAlgorithms::subtractNoAlloc__SMR.SMCR.SM::value_type"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a39328d2152a736df9c5f0406aca202a5"></span><em class="property">static</em> void <code class="descname">subtractNoAlloc</code><span class="sig-paren">(</span>SM &amp;<em>A</em>, <em class="property">const</em> SM &amp;<em>B</em>, <em class="property">typename</em> SM::value_type <em>minFloor</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms15subtractNoAllocER2SMRK2SMN2SM10value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Subtracts the non-zeros of B from the non-zeros of A. </p>
<p>Assumes that everywhere B has a non-zeros, A has a non-zero. Non-zeros of A that don&#8217;t match up with a non-zero of B are unaffected.</p>
<p>[[1 0 2] - [[3 0 0] = [[-2 0 2] [0 3 0]] [0 1 0]] [0 2 0]] </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms13assignNoAllocER2SMRK2SM">
<span id="nupic::SparseMatrixAlgorithms::assignNoAlloc__SMR.SMCR"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a78ed027f5f67ca3e25b080652f022e47"></span><em class="property">static</em> void <code class="descname">assignNoAlloc</code><span class="sig-paren">(</span>SM &amp;<em>A</em>, <em class="property">const</em> SM &amp;<em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms13assignNoAllocER2SMRK2SM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the values of the non-zeros of B into A, where A and B have a non-zero in the same location. </p>
<p>Leaves the other non-zeros of A unchanged.</p>
<p>TODO: move to SM copy, with parameter to re-use memory </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM, <em class="property">typename</em> SM01&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms23assignNoAllocFromBinaryER2SMRK4SM01">
<span id="nupic::SparseMatrixAlgorithms::assignNoAllocFromBinary__SMR.SM01CR"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a6f2f27e7e8055f40da3348a8e965837e"></span><em class="property">static</em> void <code class="descname">assignNoAllocFromBinary</code><span class="sig-paren">(</span>SM &amp;<em>A</em>, <em class="property">const</em> SM01 &amp;<em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms23assignNoAllocFromBinaryER2SMRK4SM01" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the values of the non-zeros of B into A, only where A and B have a non-zero in the same location. </p>
<p>The other non-zeros of A are left unchanged. SM2 is assumed to be a binary matrix.</p>
<p>TODO: maybe a constructor of SM, or a copy method with an argument to re-use the memory. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM, <em class="property">typename</em> SM01&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms21addConstantOnNonZerosER2SMRK4SM01N2SM10value_typeE">
<span id="nupic::SparseMatrixAlgorithms::addConstantOnNonZeros__SMR.SM01CR.SM::value_type"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a754b364083b2ada972fe25511ef80b14"></span><em class="property">static</em> void <code class="descname">addConstantOnNonZeros</code><span class="sig-paren">(</span>SM &amp;<em>A</em>, <em class="property">const</em> SM01 &amp;<em>B</em>, <em class="property">typename</em> SM::value_type <em>cval</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms21addConstantOnNonZerosER2SMRK4SM01N2SM10value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Adds a constant value on nonzeros of one SparseMatrix(B) to another (A). </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms13logSumNoAllocER2SMRK2SMN2SM10value_typeE">
<span id="nupic::SparseMatrixAlgorithms::logSumNoAlloc__SMR.SMCR.SM::value_type"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a969042c2c14a1bb09c38aff52373c4b4"></span><em class="property">static</em> void <code class="descname">logSumNoAlloc</code><span class="sig-paren">(</span>SM &amp;<em>A</em>, <em class="property">const</em> SM &amp;<em>B</em>, <em class="property">typename</em> SM::value_type <em>minFloor</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms13logSumNoAllocER2SMRK2SMN2SM10value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the sum of two SMs that are in log space. </p>
<p>A = log(exp(A) + exp(B)), but only for the non-zeros of B. A and B are already in log space. A has non-zeros everywhere that B does. This assumes that the operation does not introduce new zeros. Note: we follow the non-zeros of B, which can be less than the non-zeros of A. If minFloor &gt; 0, any value that drops below minFloor becomes minFloor. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms16logAddValNoAllocER2SMN2SM10value_typeEN2SM10value_typeE">
<span id="nupic::SparseMatrixAlgorithms::logAddValNoAlloc__SMR.SM::value_type.SM::value_type"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1ab4249d4142753ea77b05c37516db2a8c"></span><em class="property">static</em> void <code class="descname">logAddValNoAlloc</code><span class="sig-paren">(</span>SM &amp;<em>A</em>, <em class="property">typename</em> SM::value_type <em>val</em>, <em class="property">typename</em> SM::value_type <em>minFloor</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms16logAddValNoAllocER2SMN2SM10value_typeEN2SM10value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Adds a constant to the non-zeros of A in log space. </p>
<p>Assumes that no new zeros are introduced. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms14logDiffNoAllocER2SMRK2SMN2SM10value_typeE">
<span id="nupic::SparseMatrixAlgorithms::logDiffNoAlloc__SMR.SMCR.SM::value_type"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a7c5c11edaac1341a3be1177cd36a2048"></span><em class="property">static</em> void <code class="descname">logDiffNoAlloc</code><span class="sig-paren">(</span>SM &amp;<em>A</em>, <em class="property">const</em> SM &amp;<em>B</em>, <em class="property">typename</em> SM::value_type <em>minFloor</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms14logDiffNoAllocER2SMRK2SMN2SM10value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the diff of two SMs that are in log space. </p>
<p>A = log(exp(A) - exp(B)), but only for the non-zeros of B. A and B are already in log space. A has non-zeros everywhere that B does. A &gt; B in all non-zeros. This assumes that the operation does not introduce new zeros. Note: we follow the non-zeros of B, which can be less than the non-zeros of A. If minFloor &gt; 0, any value that drops below minFloor becomes minFloor. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms11LBP_piPrimeER2SMN2SM10value_typeE">
<span id="nupic::SparseMatrixAlgorithms::LBP_piPrime__SMR.SM::value_type"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a0cb801c665d4d973be5af4f6742b542f"></span><em class="property">static</em> void <code class="descname">LBP_piPrime</code><span class="sig-paren">(</span>SM &amp;<em>mat</em>, <em class="property">typename</em> SM::value_type <em>max_floor</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms11LBP_piPrimeER2SMN2SM10value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Algorithm to compute piPrime in loopy belief propagation. </p>
<p>The net operation performed is prod(col)/element, but it is performed in log mode and the mat argument is assumed to have already been converted to log mode. All values within mat are between 0 and 1 in normal space (-inf and -epsilon in log space).</p>
<p>This does a sum of each column, then places colSum-element into each location, insuring that no new zeros are introduced. Any result that would have computed to 0 (within max_floor) will be replaced with max_floor </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM, <em class="property">typename</em> STR3F&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms13assignNoAllocER2SMRK5STR3FN2SM9size_typeE">
<span id="nupic::SparseMatrixAlgorithms::assignNoAlloc__SMR.STR3FCR.SM::size_type"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a582b4e609c78050892363b02d40fe797"></span><em class="property">static</em> void <code class="descname">assignNoAlloc</code><span class="sig-paren">(</span>SM &amp;<em>A</em>, <em class="property">const</em> STR3F &amp;<em>B</em>, <em class="property">typename</em> SM::size_type <em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms13assignNoAllocER2SMRK5STR3FN2SM9size_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the values of the non-zeros of B into A, only where A and B have a non-zero in the same location. </p>
<p>The other non-zeros of A are left unchanged. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM, <em class="property">typename</em> STR3F&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms13logSumNoAllocER5STR3FN2SM9size_typeERK2SMN2SM10value_typeE">
<span id="nupic::SparseMatrixAlgorithms::logSumNoAlloc__STR3FR.SM::size_type.SMCR.SM::value_type"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1ae0d9115a1ff2b62b0b212a320c9017cb"></span><em class="property">static</em> void <code class="descname">logSumNoAlloc</code><span class="sig-paren">(</span>STR3F &amp;<em>A</em>, <em class="property">typename</em> SM::size_type <em>s</em>, <em class="property">const</em> SM &amp;<em>B</em>, <em class="property">typename</em> SM::value_type <em>minFloor</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms13logSumNoAllocER5STR3FN2SM9size_typeERK2SMN2SM10value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the sum in log space of A and B, where A is a slice of a STR3F and B is a SM. </p>
<p>The operation is: a = log(exp(a) + exp(b)), where a is a non-zero of slice s of A, and b is the corresponding non-zero of B (in the same location).</p>
<p>The number of non-zeros of in A is unchanged, and if the absolute value of a non-zero would fall below minFloor, it is replaced by minFloor. A and B need to have the same dimensions. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> SM, <em class="property">typename</em> STR3F&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms14logDiffNoAllocER5STR3FN2SM9size_typeERK2SMN2SM10value_typeE">
<span id="nupic::SparseMatrixAlgorithms::logDiffNoAlloc__STR3FR.SM::size_type.SMCR.SM::value_type"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a82a10acf3bb2c4b06f909768614d568b"></span><em class="property">static</em> void <code class="descname">logDiffNoAlloc</code><span class="sig-paren">(</span>STR3F &amp;<em>A</em>, <em class="property">typename</em> SM::size_type <em>s</em>, <em class="property">const</em> SM &amp;<em>B</em>, <em class="property">typename</em> SM::value_type <em>minFloor</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms14logDiffNoAllocER5STR3FN2SM9size_typeERK2SMN2SM10value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the diff in log space of A and B, where A is a slice of a STR3F and B is a SM. </p>
<p>The operation is: a = log(exp(a) - exp(b)), where a is a non-zero of slice s of A, and b is the corresponding non-zero of B (in the same location).</p>
<p>The number of non-zeros of in A is unchanged, and if the absolute value of a non-zero would fall below minFloor, it is replaced by minFloor. A and B need to have the same dimensions. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> STR3F&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms13assignNoAllocER5STR3FN5STR3F9size_typeERK5STR3FN5STR3F9size_typeE">
<span id="nupic::SparseMatrixAlgorithms::assignNoAlloc__STR3FR.STR3F::size_type.STR3FCR.STR3F::size_type"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1ad27d1d51840d7a8b4cdc707c5fb13f72"></span><em class="property">static</em> void <code class="descname">assignNoAlloc</code><span class="sig-paren">(</span>STR3F &amp;<em>A</em>, <em class="property">typename</em> STR3F::size_type <em>slice_a</em>, <em class="property">const</em> STR3F &amp;<em>B</em>, <em class="property">typename</em> STR3F::size_type <em>slice_b</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms13assignNoAllocER5STR3FN5STR3F9size_typeERK5STR3FN5STR3F9size_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Updates A only where A and B have a non-zero in the same location, by copying the corresponding non-zero of B. </p>
<p>The other non-zeros of A are left unchanged. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> STR3F&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms13logSumNoAllocER5STR3FN5STR3F9size_typeERK5STR3FN5STR3F9size_typeEN5STR3F10value_typeE">
<span id="nupic::SparseMatrixAlgorithms::logSumNoAlloc__STR3FR.STR3F::size_type.STR3FCR.STR3F::size_type.STR3F::value_type"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1ae613078042301153ea2051db25a04f7b"></span><em class="property">static</em> void <code class="descname">logSumNoAlloc</code><span class="sig-paren">(</span>STR3F &amp;<em>A</em>, <em class="property">typename</em> STR3F::size_type <em>slice_a</em>, <em class="property">const</em> STR3F &amp;<em>B</em>, <em class="property">typename</em> STR3F::size_type <em>slice_b</em>, <em class="property">typename</em> STR3F::value_type <em>minFloor</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms13logSumNoAllocER5STR3FN5STR3F9size_typeERK5STR3FN5STR3F9size_typeEN5STR3F10value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the sum in log space of A and B, where A is a slice of a STR3F and B is another slice of another STR3F. </p>
<p>The operation is: a = log(exp(a) + exp(b)), where a is a non-zero of slice s of A, and b is the corresponding non-zero of B (in the same location).</p>
<p>The number of non-zeros of in A is unchanged, and if the absolute value of a non-zero would fall below minFloor, it is replaced by minFloor. A and B need to have the same dimensions. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> STR3F&gt;</dt>
<dt id="_CPPv2N5nupic22SparseMatrixAlgorithms14logDiffNoAllocER5STR3FN5STR3F9size_typeERK5STR3FN5STR3F9size_typeEN5STR3F10value_typeE">
<span id="nupic::SparseMatrixAlgorithms::logDiffNoAlloc__STR3FR.STR3F::size_type.STR3FCR.STR3F::size_type.STR3F::value_type"></span><span class="target" id="nupic.corestructnupic_1_1_sparse_matrix_algorithms_1a30a7ec1f01ae71e473bc3aa63606d2b2"></span><em class="property">static</em> void <code class="descname">logDiffNoAlloc</code><span class="sig-paren">(</span>STR3F &amp;<em>A</em>, <em class="property">typename</em> STR3F::size_type <em>slice_a</em>, <em class="property">const</em> STR3F &amp;<em>B</em>, <em class="property">typename</em> STR3F::size_type <em>slice_b</em>, <em class="property">typename</em> STR3F::value_type <em>minFloor</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic22SparseMatrixAlgorithms14logDiffNoAllocER5STR3FN5STR3F9size_typeERK5STR3FN5STR3F9size_typeEN5STR3F10value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the diff in log space of A and B, where A is a slice of a STR3F and B is another slice of another STR3F. </p>
<p>The operation is: a = log(exp(a) - exp(b)), where a is a non-zero of slice s of A, and b is the corresponding non-zero of B (in the same location).</p>
<p>The number of non-zeros of in A is unchanged, and if the absolute value of a non-zero would fall below minFloor, it is replaced by minFloor. A and B need to have the same dimensions. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="sparsematrixconnections">
<h2>SparseMatrixConnections<a class="headerlink" href="#sparsematrixconnections" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N5nupic23SparseMatrixConnectionsE">
<span id="nupic::SparseMatrixConnections"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_matrix_connections"></span><em class="property">class </em><code class="descclassname">nupic::</code><code class="descname">SparseMatrixConnections</code><a class="headerlink" href="#_CPPv2N5nupic23SparseMatrixConnectionsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wraps the SparseMatrix with an easy-to-read API that stores dendrite segments as rows in the matrix. </p>
<p>The internal SparseMatrix is part of the public API. It is exposed via the &#8220;matrix&#8221; member variable. </p>
<p>Inherits from <a class="reference internal" href="#nupic.coreclassnupic_1_1_segment_matrix_adapter"><span class="std std-ref">nupic::SegmentMatrixAdapter&lt; SparseMatrix&lt; UInt32, Real32, Int32, Real64 &gt; &gt;</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N5nupic23SparseMatrixConnections23SparseMatrixConnectionsE6UInt326UInt32">
<span id="nupic::SparseMatrixConnections::SparseMatrixConnections__UInt32.UInt32"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_matrix_connections_1ae6bc6743720e54ebfc7463bcac2da1b3"></span><code class="descname">SparseMatrixConnections</code><span class="sig-paren">(</span>UInt32 <em>numCells</em>, UInt32 <em>numInputs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic23SparseMatrixConnections23SparseMatrixConnectionsE6UInt326UInt32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_matrix_connections"><span class="std std-ref">SparseMatrixConnections</span></a> constructor. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">numCells</span></code>: The number of cells in this Connections</li>
<li><code class="docutils literal"><span class="pre">numInputs</span></code>: The number of input bits, i.e. the number of columns in the internal SparseMatrix </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic23SparseMatrixConnections15computeActivityEPK6UInt32PK6UInt32P5Int32">
<span id="nupic::SparseMatrixConnections::computeActivity__UInt32CP.UInt32CP.Int32PC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_matrix_connections_1a36c37729968cedcc7ba45494fc5441f3"></span>void <code class="descname">computeActivity</code><span class="sig-paren">(</span><em class="property">const</em> UInt32 *<em>activeInputs_begin</em>, <em class="property">const</em> UInt32 *<em>activeInputs_end</em>, Int32 *<em>overlaps_begin</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic23SparseMatrixConnections15computeActivityEPK6UInt32PK6UInt32P5Int32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute the number of active synapses on each segment. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">activeInputs</span></code>: The active input bits</li>
<li><code class="docutils literal"><span class="pre">overlaps</span></code>: <a class="reference internal" href="network-io.html#nupic.coreclassnupic_1_1_output"><span class="std std-ref">Output</span></a> buffer that will be filled with a number of active synapses for each segment. This number is the &#8220;overlap&#8221; between the input SDR and the SDR formed by each segment&#8217;s synapses. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic23SparseMatrixConnections15computeActivityEPK6UInt32PK6UInt326Real32P5Int32">
<span id="nupic::SparseMatrixConnections::computeActivity__UInt32CP.UInt32CP.Real32.Int32PC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_matrix_connections_1a507ffef9233e34a2b112d69bcbae7939"></span>void <code class="descname">computeActivity</code><span class="sig-paren">(</span><em class="property">const</em> UInt32 *<em>activeInputs_begin</em>, <em class="property">const</em> UInt32 *<em>activeInputs_end</em>, Real32 <em>permanenceThreshold</em>, Int32 *<em>overlaps_begin</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic23SparseMatrixConnections15computeActivityEPK6UInt32PK6UInt326Real32P5Int32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute the number of active connected synapses on each segment. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">activeInputs</span></code>: The active input bits</li>
<li><code class="docutils literal"><span class="pre">permanenceThreshold</span></code>: The minimum permanence required for a synapse to be &#8220;connected&#8221;</li>
<li><code class="docutils literal"><span class="pre">overlaps</span></code>: <a class="reference internal" href="network-io.html#nupic.coreclassnupic_1_1_output"><span class="std std-ref">Output</span></a> buffer that will be filled with a number of active connected synapses for each segment. This number is the &#8220;overlap&#8221; between the input SDR and the SDR formed by each segment&#8217;s connected synapses. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic23SparseMatrixConnections14adjustSynapsesEPK6UInt32PK6UInt32PK6UInt32PK6UInt326Real326Real32">
<span id="nupic::SparseMatrixConnections::adjustSynapses__UInt32CP.UInt32CP.UInt32CP.UInt32CP.Real32.Real32"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_matrix_connections_1ad9e6dafb53dca9ee9fe19a5257c8db7d"></span>void <code class="descname">adjustSynapses</code><span class="sig-paren">(</span><em class="property">const</em> UInt32 *<em>segments_begin</em>, <em class="property">const</em> UInt32 *<em>segments_end</em>, <em class="property">const</em> UInt32 *<em>activeInputs_begin</em>, <em class="property">const</em> UInt32 *<em>activeInputs_end</em>, Real32 <em>activePermanenceDelta</em>, Real32 <em>inactivePermanenceDelta</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic23SparseMatrixConnections14adjustSynapsesEPK6UInt32PK6UInt32PK6UInt32PK6UInt326Real326Real32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>For each specified segment, update the permanence of each synapse according to whether the synapse would be active given the specified active inputs. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">segments</span></code>: The segments to modify</li>
<li><code class="docutils literal"><span class="pre">activeInputs</span></code>: The active inputs. Used to compute the active synapses.</li>
<li><code class="docutils literal"><span class="pre">activePermanenceDelta</span></code>: Additive constant for each active synapse&#8217;s permanence</li>
<li><code class="docutils literal"><span class="pre">inactivePermanenceDelta</span></code>: Additive constant for each inactive synapse&#8217;s permanence </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic23SparseMatrixConnections20adjustActiveSynapsesEPK6UInt32PK6UInt32PK6UInt32PK6UInt326Real32">
<span id="nupic::SparseMatrixConnections::adjustActiveSynapses__UInt32CP.UInt32CP.UInt32CP.UInt32CP.Real32"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_matrix_connections_1adfee117ca338f2767842e9b00e78a50b"></span>void <code class="descname">adjustActiveSynapses</code><span class="sig-paren">(</span><em class="property">const</em> UInt32 *<em>segments_begin</em>, <em class="property">const</em> UInt32 *<em>segments_end</em>, <em class="property">const</em> UInt32 *<em>activeInputs_begin</em>, <em class="property">const</em> UInt32 *<em>activeInputs_end</em>, Real32 <em>permanenceDelta</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic23SparseMatrixConnections20adjustActiveSynapsesEPK6UInt32PK6UInt32PK6UInt32PK6UInt326Real32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>For each specified segment, add a delta to the permanences of the synapses that would be active given the specified active inputs. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">segments</span></code>: The segments to modify</li>
<li><code class="docutils literal"><span class="pre">activeInputs</span></code>: The active inputs. Used to compute the active synapses.</li>
<li><code class="docutils literal"><span class="pre">permanenceDelta</span></code>: Additive constant for each active synapse&#8217;s permanence </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic23SparseMatrixConnections22adjustInactiveSynapsesEPK6UInt32PK6UInt32PK6UInt32PK6UInt326Real32">
<span id="nupic::SparseMatrixConnections::adjustInactiveSynapses__UInt32CP.UInt32CP.UInt32CP.UInt32CP.Real32"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_matrix_connections_1a60947045d235379d20d6fa8019a70c3f"></span>void <code class="descname">adjustInactiveSynapses</code><span class="sig-paren">(</span><em class="property">const</em> UInt32 *<em>segments_begin</em>, <em class="property">const</em> UInt32 *<em>segments_end</em>, <em class="property">const</em> UInt32 *<em>activeInputs_begin</em>, <em class="property">const</em> UInt32 *<em>activeInputs_end</em>, Real32 <em>permanenceDelta</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic23SparseMatrixConnections22adjustInactiveSynapsesEPK6UInt32PK6UInt32PK6UInt32PK6UInt326Real32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>For each specified segment, add a delta to the permanences of the synapses that would be inactive given the specified active inputs. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">segments</span></code>: The segments to modify</li>
<li><code class="docutils literal"><span class="pre">activeInputs</span></code>: The active inputs. Used to compute the active synapses.</li>
<li><code class="docutils literal"><span class="pre">permanenceDelta</span></code>: Additive constant for each inactive synapse&#8217;s permanence </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic23SparseMatrixConnections12growSynapsesEPK6UInt32PK6UInt32PK6UInt32PK6UInt326Real32">
<span id="nupic::SparseMatrixConnections::growSynapses__UInt32CP.UInt32CP.UInt32CP.UInt32CP.Real32"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_matrix_connections_1ac9e9d1bb512465f2b2ff914357b317fd"></span>void <code class="descname">growSynapses</code><span class="sig-paren">(</span><em class="property">const</em> UInt32 *<em>segments_begin</em>, <em class="property">const</em> UInt32 *<em>segments_end</em>, <em class="property">const</em> UInt32 *<em>inputs_begin</em>, <em class="property">const</em> UInt32 *<em>inputs_end</em>, Real32 <em>initialPermanence</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic23SparseMatrixConnections12growSynapsesEPK6UInt32PK6UInt32PK6UInt32PK6UInt326Real32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>For each specified segments, grow synapses to all specified inputs that aren&#8217;t already connected to the segment. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">segments</span></code>: The segments to modify</li>
<li><code class="docutils literal"><span class="pre">inputs</span></code>: The inputs to connect to</li>
<li><code class="docutils literal"><span class="pre">initialPermanence</span></code>: The permanence for each added synapse </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic23SparseMatrixConnections20growSynapsesToSampleEPK6UInt32PK6UInt32PK6UInt32PK6UInt325Int326Real32RN5nupic6RandomE">
<span id="nupic::SparseMatrixConnections::growSynapsesToSample__UInt32CP.UInt32CP.UInt32CP.UInt32CP.Int32.Real32.nupic::RandomR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_matrix_connections_1a74667e4d9f8c051b323a06c6a8e27a42"></span>void <code class="descname">growSynapsesToSample</code><span class="sig-paren">(</span><em class="property">const</em> UInt32 *<em>segments_begin</em>, <em class="property">const</em> UInt32 *<em>segments_end</em>, <em class="property">const</em> UInt32 *<em>inputs_begin</em>, <em class="property">const</em> UInt32 *<em>inputs_end</em>, Int32 <em>sampleSize</em>, Real32 <em>initialPermanence</em>, nupic::Random &amp;<em>rng</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic23SparseMatrixConnections20growSynapsesToSampleEPK6UInt32PK6UInt32PK6UInt32PK6UInt325Int326Real32RN5nupic6RandomE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>For each specified segments, grow synapses to a random subset of the inputs that aren&#8217;t already connected to the segment. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">segments</span></code>: The segments to modify</li>
<li><code class="docutils literal"><span class="pre">inputs</span></code>: The inputs to sample</li>
<li><code class="docutils literal"><span class="pre">sampleSize</span></code>: The number of synapses to attempt to grow per segment</li>
<li><code class="docutils literal"><span class="pre">initialPermanence</span></code>: The permanence for each added synapse</li>
<li><code class="docutils literal"><span class="pre">rng</span></code>: Random number generator </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic23SparseMatrixConnections20growSynapsesToSampleEPK6UInt32PK6UInt32PK6UInt32PK6UInt32PK5Int32PK5Int326Real32RN5nupic6RandomE">
<span id="nupic::SparseMatrixConnections::growSynapsesToSample__UInt32CP.UInt32CP.UInt32CP.UInt32CP.Int32CP.Int32CP.Real32.nupic::RandomR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_matrix_connections_1aa1f05ad5d635216d2a702f4396104eee"></span>void <code class="descname">growSynapsesToSample</code><span class="sig-paren">(</span><em class="property">const</em> UInt32 *<em>segments_begin</em>, <em class="property">const</em> UInt32 *<em>segments_end</em>, <em class="property">const</em> UInt32 *<em>inputs_begin</em>, <em class="property">const</em> UInt32 *<em>inputs_end</em>, <em class="property">const</em> Int32 *<em>sampleSizes_begin</em>, <em class="property">const</em> Int32 *<em>sampleSizes_end</em>, Real32 <em>initialPermanence</em>, nupic::Random &amp;<em>rng</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic23SparseMatrixConnections20growSynapsesToSampleEPK6UInt32PK6UInt32PK6UInt32PK6UInt32PK5Int32PK5Int326Real32RN5nupic6RandomE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>For each specified segments, grow synapses to a random subset of the inputs that aren&#8217;t already connected to the segment. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">segments</span></code>: The segments to modify</li>
<li><code class="docutils literal"><span class="pre">inputs</span></code>: The inputs to sample</li>
<li><code class="docutils literal"><span class="pre">sampleSizes</span></code>: The number of synapses to attempt to grow for each segment. This list must be the same length as &#8216;segments&#8217;.</li>
<li><code class="docutils literal"><span class="pre">initialPermanence</span></code>: The permanence for each added synapse</li>
<li><code class="docutils literal"><span class="pre">rng</span></code>: Random number generator </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic23SparseMatrixConnections15clipPermanencesEPK6UInt32PK6UInt32">
<span id="nupic::SparseMatrixConnections::clipPermanences__UInt32CP.UInt32CP"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_matrix_connections_1aae11a74baf90cb180a10ceca0b99552b"></span>void <code class="descname">clipPermanences</code><span class="sig-paren">(</span><em class="property">const</em> UInt32 *<em>segments_begin</em>, <em class="property">const</em> UInt32 *<em>segments_end</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic23SparseMatrixConnections15clipPermanencesEPK6UInt32PK6UInt32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clip all permanences to a minimum of 0.0 and a maximum of 1.0. </p>
<p>For any synapse with &lt;= 0.0 permanence, destroy the synapse. For any synapse with &gt; 1.0 permanence, set the permanence to 1.0.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">segments</span></code>: The segments to modify </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic23SparseMatrixConnections26mapSegmentsToSynapseCountsEPK6UInt32PK6UInt32P5Int32">
<span id="nupic::SparseMatrixConnections::mapSegmentsToSynapseCounts__UInt32CP.UInt32CP.Int32PC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_matrix_connections_1a373b8ab0ab5658b44fb0ff567fd423b4"></span>void <code class="descname">mapSegmentsToSynapseCounts</code><span class="sig-paren">(</span><em class="property">const</em> UInt32 *<em>segments_begin</em>, <em class="property">const</em> UInt32 *<em>segments_end</em>, Int32 *<em>out_begin</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic23SparseMatrixConnections26mapSegmentsToSynapseCountsEPK6UInt32PK6UInt32P5Int32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of synapses for each specified segment. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">segments</span></code>: The segments to query</li>
<li><code class="docutils literal"><span class="pre">out</span></code>: An output buffer that will be filled with the counts </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="sparserlematrix">
<h2>SparseRLEMatrix<a class="headerlink" href="#sparserlematrix" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt>
<span class="target" id="nupic.coreclassnupic_1_1_sparse_r_l_e_matrix"></span><em class="property">template </em>&lt;<em class="property">typename</em> <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>, <em class="property">typename</em> Value&gt;</dt>
<dt id="_CPPv2N5nupic15SparseRLEMatrixE">
<span id="nupic::SparseRLEMatrix"></span><em class="property">class </em><code class="descclassname">nupic::</code><code class="descname">SparseRLEMatrix</code><a class="headerlink" href="#_CPPv2N5nupic15SparseRLEMatrixE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A matrix where only the positions and values of runs of non-zeros are stored. </p>
<p>Optionally compresses values using zlib (off by default).</p>
<p>WATCH OUT! That the <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a> type doesn&#8217;t become too small to store parameters of the matrix, such as total number of non-zeros.</p>
<p>TODO: run length encode different values, which can be valuable when quantizing vector components. This could be another data structure. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N5nupic15SparseRLEMatrix7compactEv">
<span id="nupic::SparseRLEMatrix::compact"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_r_l_e_matrix_1a4a4a4c4069d8dad24f3bb6f6f9c9aca9"></span>void <code class="descname">compact</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic15SparseRLEMatrix7compactEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Adjusts the size of the internal vectors so that their capacity matches their size. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic15SparseRLEMatrix12compressDataEv">
<span id="nupic::SparseRLEMatrix::compressData"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_r_l_e_matrix_1af47cfae43779add55d64814beb91bf80"></span>void <code class="descname">compressData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic15SparseRLEMatrix12compressDataEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compress data using compression algorithm. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic15SparseRLEMatrix5clearEv">
<span id="nupic::SparseRLEMatrix::clear"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_r_l_e_matrix_1aa0302350fb5576652baae6842f8dcaec"></span>void <code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic15SparseRLEMatrix5clearEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Deallocates memory used by this instance. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator&gt;</dt>
<dt id="_CPPv2N5nupic15SparseRLEMatrix9appendRowE13InputIterator13InputIterator">
<span id="nupic::SparseRLEMatrix::appendRow__InputIterator.InputIterator"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_r_l_e_matrix_1adbeaddb56cda9d181ccf16804ac99163"></span>void <code class="descname">appendRow</code><span class="sig-paren">(</span>InputIterator <em>begin</em>, InputIterator <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic15SparseRLEMatrix9appendRowE13InputIterator13InputIterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Appends a row to this matrix. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator&gt;</dt>
<dt id="_CPPv2NK5nupic15SparseRLEMatrix18firstRowCloserThanE13InputIterator13InputIteratorN5nupic6Real32E">
<span id="nupic::SparseRLEMatrix::firstRowCloserThan__InputIterator.InputIterator.nupic::Real32C"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_r_l_e_matrix_1a0cca396d17c09b8d4bac0363a303b1d9"></span>ulong_size_type <code class="descname">firstRowCloserThan</code><span class="sig-paren">(</span>InputIterator <em>begin</em>, InputIterator <em>end</em>, nupic::Real32 <em>distance</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic15SparseRLEMatrix18firstRowCloserThanE13InputIterator13InputIteratorN5nupic6Real32E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns index of first row within &lt;distance&gt; of argument, or nRows() if none. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InputIterator&gt;</dt>
<dt id="_CPPv2N5nupic15SparseRLEMatrix9fromDenseE15ulong_size_type9size_type13InputIterator13InputIterator">
<span id="nupic::SparseRLEMatrix::fromDense__ulong_size_type.size_type.InputIterator.InputIterator"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_r_l_e_matrix_1a73ab41ba1bfc785bf6939ba2ebf0c019"></span>void <code class="descname">fromDense</code><span class="sig-paren">(</span>ulong_size_type <em>nrows</em>, size_type <em>ncols</em>, InputIterator <em>begin</em>, InputIterator <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic15SparseRLEMatrix9fromDenseE15ulong_size_type9size_type13InputIterator13InputIterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clears this instance and creates a new one from dense. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="sparsetensor">
<h2>SparseTensor<a class="headerlink" href="#sparsetensor" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt>
<span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor"></span><em class="property">template </em>&lt;typename <em>Index</em>, typename <em>Float</em>&gt;</dt>
<dt id="_CPPv2N5nupic12SparseTensorE">
<span id="nupic::SparseTensor"></span><em class="property">class </em><code class="descclassname">nupic::</code><code class="descname">SparseTensor</code><a class="headerlink" href="#_CPPv2N5nupic12SparseTensorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong>Description</strong> <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a> models a multi-dimensional array, with an arbitrary number of dimensions, and arbitrary size for each dimension, where only certain elements are not zero. </p>
<p>&#8220;Not zero&#8221; is defined as being outside the closed ball [-nupic::Epsilon..nupic::Epsilon]. Zero elements are not stored. Non-zero elements are stored in a data structure that provides logarithmic insertion and retrieval. A number of operations on tensors are implemented as efficiently as possible, oftentimes having complexity not worse than the number of non-zeros in the tensor. There is no limit to the number of dimensions that can be specified for a sparse tensor.</p>
<p><a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a> is parameterized on the type of <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a> used to index the non-zeros, and on the type of the non-zeros themselves (Float). The numerical type used as the second template parameter needs to be functionally equivalent to float, but can be int or double. It doesn&#8217;t work with complex numbers yet (have to modify nearlyZero_ to look at the modulus).</p>
<p>The implementation relies on a Unique, Sorted Associative NZ, that is map (rather than hash_map, we need the Indices to be sorted).</p>
<p>Examples: 1) <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a>&lt;Index&lt;UInt, 2&gt;, float&gt;: defines a sparse tensor of dimension 2 (a matrix), storing floats. The type of <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a> is the efficient, compile-time sized <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>.</p>
<p>2) <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a>&lt;std::vector&lt;UInt&gt;, float&gt;: defines the same sparse tensor as 1), but using std::vector&lt;UInt&gt; for the index, which is not as fast.</p>
<p>3) <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a>&lt;Index&lt;UInt, 4&gt; double&gt;: defines a sparse tensor of rank 4 (4 dimensions), storing doubles.</p>
<p><strong>Responsibility</strong> An efficient multi-dimensional sparse data structure</p>
<p><strong>Rationale</strong> Numenta algorithms require very large data structure that are sparse, and those data structures cannot be handled efficiently with contiguous storage in memory.</p>
<p><strong>Resource</strong><a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a> owns the keys used to index the non-zeros, as well as the values of the non-zeros themselves.</p>
<p><strong>Notes</strong> Note 1: in preliminary testing, using Index&lt;UInt, Rank&gt; was about 20 times faster than using std::vector&lt;UInt&gt;.</p>
<p>Note 2: some operations are very slow, depending on the properties of the functors used. Watch out that you are using the right one for your functor.</p>
<p>Note 3: <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a> is limited to max&lt;unsigned long&gt; columns, or rows or non-zeros. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor12SparseTensorE4UIntz">
<span id="nupic::SparseTensor::SparseTensor__UInt.z"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1adaa452283e79806063238cde2f3973e8"></span><code class="descname">SparseTensor</code><span class="sig-paren">(</span>UInt <em>ub0</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor12SparseTensorE4UIntz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a> constructor from list of bounds. </p>
<p>The constructed instance is identically zero. Each of the integers passed in represents the size of this sparse tensor along a given dimension. There need to be as many integers passed in as this tensor has dimensions. All the integers need to be &gt; 0.</p>
<p>Note: This constructor will not work with <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a> = std::vector</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">ub</span></code>: [UInt &gt;= 0] the size of this tensor along one dimension </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor12SparseTensorERK5Index">
<span id="nupic::SparseTensor::SparseTensor__IndexCR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a8bafe4b3160ea7e2dfaae91ccd07e9c6"></span><code class="descname">SparseTensor</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>bounds</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor12SparseTensorERK5Index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a> constructor from <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a> that contains the bounds. </p>
<p>The constructed instance is identically zero. The size of the <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a> becomes the rank of this sparse tensor, that is, its number of dimensions. The values of each element of the index need to be &gt; 0.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">bounds</span></code>: [<a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>] the bounds of each dimension </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor12SparseTensorERK12SparseTensor">
<span id="nupic::SparseTensor::SparseTensor__SparseTensorCR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1ac9cd8d410d0d29b7c1afa698f28ab371"></span><code class="descname">SparseTensor</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensor12SparseTensorE4UIntz" title="nupic::SparseTensor::SparseTensor">SparseTensor</a> &amp;<em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor12SparseTensorERK12SparseTensor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a> copy constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensoraSERK12SparseTensor">
<span id="nupic::SparseTensor::assign-operator__SparseTensorCR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1abde48732a4eb8a1c3d2920f404f47352"></span><a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a> &amp;<code class="descname">operator=</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a> &amp;<em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensoraSERK12SparseTensor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assignment operator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor4swapER12SparseTensorI5Index5FloatE">
<span id="nupic::SparseTensor::swap__SparseTensor:Index.Float:R"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1af96eeb5771ec76dbc8e7fc88837d1a82"></span>void <code class="descname">swap</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;<a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a>, Float&gt; &amp;<em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor4swapER12SparseTensorI5Index5FloatE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Swaps the contents of two tensors. </p>
<p>The two tensors need to have the same rank, but they don&#8217;t need to have the same dimensions.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">B</span></code>: [SparseTensor&lt;Index, Float&gt;] the tensor to swap with </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor7getRankEv">
<span id="nupic::SparseTensor::getRankC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a6712936d3ca0b1824aeb768b225f3412"></span><em class="property">const</em> UInt <code class="descname">getRank</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor7getRankEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the rank of this tensor. </p>
<p>The rank is the number of dimensions of this sparse tensor, it is an integer &gt;= 1.</p>
<p>Examples: A tensor of rank 0 is a scalar (not possible here). A tensor of rank 1 is a vector. A tensor of rank 2 is a matrix.</p>
<p><dl class="docutils">
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">UInt</span></code>: [ &gt; 0 ] the rank of this sparse tensor </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor9getBoundsEv">
<span id="nupic::SparseTensor::getBoundsC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a10d364327ea1582f93ce668abe5befa2"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> <code class="descname">getBounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor9getBoundsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the bounds of this tensor, that is the size of this tensor along each of its dimensions. </p>
<p>Tensor indices start at zero along all dimensions. The product of the bounds is the total number of elements that this sparse tensor can store.</p>
<p>Examples: A 3 long vector has bounds Index(3). A 10x10 matrix has bounds: Index(10, 10).</p>
<p><dl class="docutils">
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref"><span class="pre">Index</span></span></a></code>: the upper bound for this sparse tensor </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor8getBoundERK4UInt">
<span id="nupic::SparseTensor::getBound__UIntCRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a165f91514eb51df267588fbefa75bee6"></span><em class="property">const</em> UInt <code class="descname">getBound</code><span class="sig-paren">(</span><em class="property">const</em> UInt &amp;<em>dim</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor8getBoundERK4UInt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the upper bound of this sparse tensor along the given dimension. </p>
<p>Example: A 3x4x5 tensor has:<ul class="simple">
<li>getBound(0) == 3, getBound(1) == 4, getBound(2) == 5.</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dim</span></code>: [0 &lt;= UInt &lt; <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor_1a6712936d3ca0b1824aeb768b225f3412"><span class="std std-ref">getRank()</span></a>] the dimension </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">[UInt</span></code>: &gt;= 0] the upper of this tensor along dim </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor9getDomainEv">
<span id="nupic::SparseTensor::getDomainC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a75c1e01d9ec73546eeccd06b40a484d2"></span><a class="reference internal" href="#_CPPv2N5nupic6DomainE" title="nupic::Domain">Domain</a>&lt;UInt&gt; <code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor9getDomainEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the domain of this sparse tensor, where the lower bound is zero and the upper bound is the upper bound. </p>
<p>Example: A 3x2x4 tensor has domain { [0..3), [0..2), [0..4) }.</p>
<p><dl class="docutils">
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">[Domain&lt;UInt&gt;]</span></code>: the domain for this tensor </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor11getSizeEltsEv">
<span id="nupic::SparseTensor::getSizeEltsC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1af2fabfebb3d2ae8737da9b6ee163f005"></span><em class="property">const</em> UInt <code class="descname">getSizeElts</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor11getSizeEltsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the total size of this sparse tensor, that is, the total number of non-zeros that can be stored. </p>
<p>It is the product of the bounds.</p>
<p>Example: A 3x3 matrix has a size of 9.</p>
<p><dl class="docutils">
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">UInt</span></code>: [ &gt; 0 ] the size of this sparse tensor </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> Index2&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor11getSizeEltsERK6Index2">
<span id="nupic::SparseTensor::getSizeElts__Index2CRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a18df225006debc2593b67ce2c0677e72"></span><em class="property">const</em> UInt <code class="descname">getSizeElts</code><span class="sig-paren">(</span><em class="property">const</em> Index2 &amp;<em>dims</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor11getSizeEltsERK6Index2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the size of a sub-space of this sparse tensor, designated by dims. </p>
<p>Example: A 3x4 matrix has a size of 4 along the columns and 3 along the rows. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor12getNNonZerosEv">
<span id="nupic::SparseTensor::getNNonZerosC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a8394f62fb9a5b5d38c3b284e312d4c14"></span><em class="property">const</em> UInt <code class="descname">getNNonZeros</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor12getNNonZerosEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of non-zeros in this sparse tensor. </p>
<p>Invariant: <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor_1a8394f62fb9a5b5d38c3b284e312d4c14"><span class="std std-ref">getNNonZeros()</span></a> + <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor_1a0eb0d8526720aaab6965004fa9f74e51"><span class="std std-ref">getNZeros()</span></a> == product(getBounds())</p>
<p><dl class="docutils">
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">UInt</span></code>: [ &gt;= 0 ] the number of non-zeros in this sparse tensor </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor9getNZerosEv">
<span id="nupic::SparseTensor::getNZerosC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a0eb0d8526720aaab6965004fa9f74e51"></span><em class="property">const</em> UInt <code class="descname">getNZeros</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor9getNZerosEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of zeros in this sparse tensor. </p>
<p>Invariant: <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor_1a0eb0d8526720aaab6965004fa9f74e51"><span class="std std-ref">getNZeros()</span></a> + <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor_1a8394f62fb9a5b5d38c3b284e312d4c14"><span class="std std-ref">getNNonZeros()</span></a> == product(getBounds())</p>
<p><dl class="docutils">
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">UInt</span></code>: [ &gt;= 0 ] the number of zeros in this sparse tensor </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor12getNNonZerosERK6DomainI4UIntE">
<span id="nupic::SparseTensor::getNNonZeros__Domain:UInt:CRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a582464c864a139eedb6f89a4dfb04b6e"></span><em class="property">const</em> UInt <code class="descname">getNNonZeros</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic6DomainE" title="nupic::Domain">Domain</a>&lt;UInt&gt; &amp;<em>dom</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor12getNNonZerosERK6DomainI4UIntE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of non-zeros in a domain of this sparse tensor. </p>
<p>Does not work with a domain that has closed dimensions. The domain needs to have the same rank as this sparse tensor.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dom</span></code>: [Domain&lt;UInt&gt;] the domain to scan for non-zeros </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">UInt</span></code>: [ &gt;= 0 ] the number of non-zeros in dom </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor9getNZerosERK6DomainI4UIntE">
<span id="nupic::SparseTensor::getNZeros__Domain:UInt:CRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1adff710f740a699c5fbc8e838a7ecce30"></span><em class="property">const</em> UInt <code class="descname">getNZeros</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic6DomainE" title="nupic::Domain">Domain</a>&lt;UInt&gt; &amp;<em>dom</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor9getNZerosERK6DomainI4UIntE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of zeros in a domain of this sparse tensor. </p>
<p>Doens&#8217;t work if the domain has closed dimensions. The domain needs to have the same rank as this sparse tensor.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dom</span></code>: [Domain&lt;UInt&gt;] the domain to scan for zeros </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">UInt</span></code>: [ &gt;= 0 ] the number of zeros in dom </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> Index2, <em class="property">typename</em> IndexB&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor12getNNonZerosERK6Index2R12SparseTensorI6IndexB5FloatE">
<span id="nupic::SparseTensor::getNNonZeros__Index2CR.SparseTensor:IndexB.Float:RC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1af0c790f755bbfac8a39dd0f31bd24a60"></span>void <code class="descname">getNNonZeros</code><span class="sig-paren">(</span><em class="property">const</em> Index2 &amp;<em>dims</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor12getNNonZerosERK6Index2R12SparseTensorI6IndexB5FloatE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of non-zeros in designated sub-spaces of this sparse tensor. </p>
<p>The sub-spaces are designated by dims. The B tensor collects the results.</p>
<p>Complexity: O(number of non-zeros)</p>
<p>Example: If A is a 11x13 sparse tensor:<ul class="simple">
<li>A.getNNonZeros(I1(1), B) returns the number of non-zeros per row in A, and B is a vector of size 11.</li>
<li>A.getNNonZeros(I1(0), B) returns the number of non-zeros per column of A, and B is a vector of size 13.</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dims</span></code>: [Index2] the dimensions along which to count the non-zeros </li>
<li><code class="docutils literal"><span class="pre">B</span></code>: [SparseTensor&lt;IndexB, Float&gt;] the sparse tensor of the number of non-zeros per sub-space </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> Index2, <em class="property">typename</em> IndexB&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor9getNZerosERK6Index2R12SparseTensorI6IndexB5FloatE">
<span id="nupic::SparseTensor::getNZeros__Index2CR.SparseTensor:IndexB.Float:RC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a3caa171df2e5e5fd7917c98d591098ae"></span>void <code class="descname">getNZeros</code><span class="sig-paren">(</span><em class="property">const</em> Index2 &amp;<em>dims</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor9getNZerosERK6Index2R12SparseTensorI6IndexB5FloatE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of zeros in designated sub-spaces of this sparse tensor. </p>
<p>See getNNonZeros doc. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor6isNullEv">
<span id="nupic::SparseTensor::isNullC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a64a4fd64cc9c391f9d551c9c478f5dce"></span>bool <code class="descname">isNull</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor6isNullEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if this <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a> is the &#8220;empty&#8221; tensor, that is, a <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a> with no value (like a matrix without rows). </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor6isZeroEv">
<span id="nupic::SparseTensor::isZeroC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a12a41bf247861088d71448f5fabf0565"></span>bool <code class="descname">isZero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor6isZeroEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if there is no non-zero in this tensor, false otherwise. </p>
<p><dl class="docutils">
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">bool</span></code>: whether this sparse tensor is identically zero or not </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor6isZeroERK6DomainI4UIntE">
<span id="nupic::SparseTensor::isZero__Domain:UInt:CRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1ab9f6264685afc5108b2d3ec11458bc42"></span>bool <code class="descname">isZero</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic6DomainE" title="nupic::Domain">Domain</a>&lt;UInt&gt; &amp;<em>dom</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor6isZeroERK6DomainI4UIntE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the domain inside this sparse tensor is identically zero. </p>
<p>Doens&#8217;t work if the domain has closed dimensions. The domain needs to have the same rank as this sparse tensor.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dom</span></code>: [Domain&lt;UInt&gt;] the domain to look at </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">bool</span></code>: whether this sparse tensor is zero inside dom </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor7isDenseEv">
<span id="nupic::SparseTensor::isDenseC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1ae950074efbcfff02d08e7b4a69d3432e"></span>bool <code class="descname">isDense</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor7isDenseEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if there are no zeros in this tensor, false otherwise. </p>
<p>The tensor is dense if it contains no zero.</p>
<p><dl class="docutils">
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">bool</span></code>: whether this tensor is dense or not </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor7isDenseERK6DomainI4UIntE">
<span id="nupic::SparseTensor::isDense__Domain:UInt:CRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1affe2f2e0129727768c3095fec597f92b"></span>bool <code class="descname">isDense</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic6DomainE" title="nupic::Domain">Domain</a>&lt;UInt&gt; &amp;<em>dom</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor7isDenseERK6DomainI4UIntE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the domain inside this sparse tensor is dense. </p>
<p>Doens&#8217;t work if the domain has closed dimensions. The domain needs to have the same rank as this sparse tensor.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dom</span></code>: [Domain&lt;UInt&gt;] the domain to look at </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">bool</span></code>: whether this sparse tensor is dense inside dom </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor8isSparseEv">
<span id="nupic::SparseTensor::isSparseC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a75d3c800575179e5f9312ba5d72318b7"></span>bool <code class="descname">isSparse</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor8isSparseEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if there are zeros in this tensor, false otherwise. </p>
<p>The tensor is sparse if it contains at least one zero.</p>
<p><dl class="docutils">
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">bool</span></code>: whether this tensor is sparse or not </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor8isSparseERK6DomainI4UIntE">
<span id="nupic::SparseTensor::isSparse__Domain:UInt:CRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1ab4998c9dccf4cd9544daeae63af45f2f"></span>bool <code class="descname">isSparse</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic6DomainE" title="nupic::Domain">Domain</a>&lt;UInt&gt; &amp;<em>dom</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor8isSparseERK6DomainI4UIntE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the domain inside this sparse tensor is sparse. </p>
<p>Doens&#8217;t work if the domain has closed dimensions. The domain needs to have the same rank as this sparse tensor.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dom</span></code>: [Domain&lt;UInt&gt;] the domain to look at </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">bool</span></code>: whether this sparse tensor is sparse inside dom </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor11getFillRateEv">
<span id="nupic::SparseTensor::getFillRateC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a0be7283999de5a7ae4aa4fcbd3492352"></span><em class="property">const</em> Float <code class="descname">getFillRate</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor11getFillRateEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the fill rate for this tensor, that is, the ratio of the number of non-zeros to the total number of elements in this tensor. </p>
<p><dl class="docutils">
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">Float</span></code>: the fill rate </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor11getFillRateERK6DomainI4UIntE">
<span id="nupic::SparseTensor::getFillRate__Domain:UInt:CRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a8754e3b53d12b414e750bd72e93f931e"></span><em class="property">const</em> Float <code class="descname">getFillRate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic6DomainE" title="nupic::Domain">Domain</a>&lt;UInt&gt; &amp;<em>dom</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor11getFillRateERK6DomainI4UIntE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the fill rate for this tensor inside the given domain, that is, the ratio of the number of non-zeros in the given domain to the size of the domain. </p>
<p><dl class="docutils">
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">Float</span></code>: the fill rate inside the given domain </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> Index2, <em class="property">typename</em> IndexB&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor11getFillRateERK6Index2R12SparseTensorI6IndexB5FloatE">
<span id="nupic::SparseTensor::getFillRate__Index2CR.SparseTensor:IndexB.Float:RC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a68348571a25fa5d6513288044e8ba299"></span>void <code class="descname">getFillRate</code><span class="sig-paren">(</span><em class="property">const</em> Index2 &amp;<em>dims</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor11getFillRateERK6Index2R12SparseTensorI6IndexB5FloatE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the fill rate for sub-spaces of this sparse tensor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor10isPositiveEv">
<span id="nupic::SparseTensor::isPositiveC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a52714d31e188ca0705c9c5e871ddbc53"></span>bool <code class="descname">isPositive</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor10isPositiveEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether this sparse tensor is positive or not, that is, whether all its coefficients are &gt; nupic::Epsilon (there are no zeros in this tensor, and all the elements have positive values). </p>
<p>Complexity: O(number of non-zeros) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor13isNonNegativeEv">
<span id="nupic::SparseTensor::isNonNegativeC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1ab78c0e12ba71935a590c3e2a1feb3a06"></span>bool <code class="descname">isNonNegative</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor13isNonNegativeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether this sparse tensor is non-negative or not, that is, whether all its coefficients are &gt;= -nupic::Epsilon (there can be zeros in this tensor, but all the non-zeros have positive values). </p>
<p>Complexity: O(number of non-zeros) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor6valuesEv">
<span id="nupic::SparseTensor::valuesC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a8d02604ea03afc1a75b17261b8190fe5"></span>std::map&lt;Float, UInt&gt; <code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor6valuesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the set of values in this <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a> and how many times each of them appears. </p>
<p>Complexity: O(number of non-zeros) with some log for the insertion in the result map... </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor5clearEv">
<span id="nupic::SparseTensor::clear"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a475e07ee8f8c1ad61c921d73f3619079"></span>void <code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor5clearEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Makes this tensor the tensor zero, that is, all the non-zeros are removed. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor11getNewIndexEv">
<span id="nupic::SparseTensor::getNewIndexC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a0550d429eb63e4e03b378a0ca31a6b7f"></span><a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> <code class="descname">getNewIndex</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor11getNewIndexEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Creates a new <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a> that has the rank of this sparse tensor. </p>
<p>The initial value of this <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a> is the bounds of this tensor.</p>
<p>Note: To accomodate both Index&lt;UInt, X&gt; and std::vector&lt;UInt&gt; as indices, we can&#8217;t allocate memory ourselves, so when we need an index, we create a copy of the bounds, and either do nothing, or set it to zero, or set to some specified set of values.</p>
<p><dl class="docutils">
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref"><span class="pre">Index</span></span></a></code>: a new <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>, that contains the values of the bounds for this sparse tensor </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor15getNewZeroIndexEv">
<span id="nupic::SparseTensor::getNewZeroIndexC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a604d01c4ce1cad2a0be6a05d2ae4a71a"></span><a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> <code class="descname">getNewZeroIndex</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor15getNewZeroIndexEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Creates a new <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a> that has the rank of this sparse tensor and sets it to zero (see note in <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor_1a0550d429eb63e4e03b378a0ca31a6b7f"><span class="std std-ref">getNewIndex()</span></a>). </p>
<p><dl class="docutils">
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref"><span class="pre">Index</span></span></a></code>: a new <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>, initialized to zero </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor11getNewIndexE4UIntz">
<span id="nupic::SparseTensor::getNewIndex__UInt.zC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a2b29ab2d27aaeadffc9a3e79d5366930"></span><a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> <code class="descname">getNewIndex</code><span class="sig-paren">(</span>UInt <em>i0</em>, ...<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor11getNewIndexE4UIntz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Creates a new <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a> that has the rank of this sparse tensor and sets it to the specified values (see note in <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor_1a0550d429eb63e4e03b378a0ca31a6b7f"><span class="std std-ref">getNewIndex()</span></a>). </p>
<p><dl class="docutils">
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref"><span class="pre">Index</span></span></a></code>: a new <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>, initialized to the values passed </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor11isSymmetricERK5Index">
<span id="nupic::SparseTensor::isSymmetric__IndexCRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a5ffa9125720314ef9814ad8f0e0a533e"></span>bool <code class="descname">isSymmetric</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>perm</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor11isSymmetricERK5Index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes whether this tensor is symmetric or not. </p>
<p>A tensor is symmetric w.r.t. a permutation of the dimensions iff: A[ijkl...] = A[permutation(ijkl...)]. This implies that the bounds of the permuted dimensions need to be the same. If they are not, the tensor is not symmetric. The <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a> passed in needs to have the same size as the rank of this sparse tensor.</p>
<p>Complexity: O(number of non-zeros)</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">perm</span></code>: [<a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>] the permutation to use to evaluate whether this sparse tensor is symmetric or not </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">bool</span></code>: whether this sparse tensor is symmetric w.r.t. the given permutation </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor15isAntiSymmetricERK5Index">
<span id="nupic::SparseTensor::isAntiSymmetric__IndexCRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a58f48f25f2f14a6536ef5961dd89e307"></span>bool <code class="descname">isAntiSymmetric</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>perm</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor15isAntiSymmetricERK5Index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes whether this tensor is anti-symmetric or not. </p>
<p>A tensor is anti-symmetric w.r.t. to a permutation of the dimensions iff: A[ijkl...] = -A[permutation(ijkl...)] This implies that the upper bounds of the permuted dimensions need to be the same, or the tensor is not anti-symmetric. The <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a> passed in needs to have the same size as the rank of this sparse tensor.</p>
<p>Complexity: O(number of non-zeros)</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">perm</span></code>: [<a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>] the permutation to use to evaluate anti-symmetry </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">bool</span></code>: whether this sparse tensor is anty-symmetric w.r.t. the given permutation or not </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor3setERK5IndexRK5Float">
<span id="nupic::SparseTensor::set__IndexCR.FloatCR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a63d0ae30075a800b6fb7e2fd6f0dd043"></span>void <code class="descname">set</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>idx</em>, <em class="property">const</em> Float &amp;<em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor3setERK5IndexRK5Float" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets the element at idx to val. </p>
<p>Handles zeros by not storing them, or by erasing non-zeros that become zeros when val = 0. The <a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a> idx needs to be &gt;= 0 and &lt; <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor_1a10d364327ea1582f93ce668abe5befa2"><span class="std std-ref">getBounds()</span></a>.</p>
<p>Complexity: O(log(number of non-zeros))</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">idx</span></code>: [<a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>] the index of the element to set </li>
<li><code class="docutils literal"><span class="pre">val</span></code>: [Float] the value to set for the element at index </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor3setE4UIntz">
<span id="nupic::SparseTensor::set__UInt.z"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a8c2f1bf9f97751d195740d795a975342"></span>void <code class="descname">set</code><span class="sig-paren">(</span>UInt <em>i0</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor3setE4UIntz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets the element at idx to val. </p>
<p>Calls set(Index, Float). </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor3setERK6DomainI4UIntERK5Float">
<span id="nupic::SparseTensor::set__Domain:UInt:CR.FloatCR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a71ea2c5327ca34fef9399e2ea6fcb4b0"></span>void <code class="descname">set</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic6DomainE" title="nupic::Domain">Domain</a>&lt;UInt&gt; &amp;<em>dom</em>, <em class="property">const</em> Float &amp;<em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor3setERK6DomainI4UIntERK5Float" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets all the elements inside the dom to val. </p>
<p>Handles zeros correctly (i.e. does not store them).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dom</span></code>: [Domain&lt;UInt&gt;] the domain inside which to set values </li>
<li><code class="docutils literal"><span class="pre">val</span></code>: [Float] the value to set inside dom </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor7setZeroERK5Index">
<span id="nupic::SparseTensor::setZero__IndexCR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1aae35e236c1eb0153290eb6bd529d7e52"></span>void <code class="descname">setZero</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>idx</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor7setZeroERK5Index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets the element at idx to zero, that is, removes it from the internal storage. </p>
<p>Complexity: O(log(number of non-zeros))</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">idx</span></code>: [<a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>] the index of the element to set to zero </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor7setZeroE4UIntz">
<span id="nupic::SparseTensor::setZero__UInt.z"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a73ef0b2bd3574897b4ca8c27a13d698e"></span>void <code class="descname">setZero</code><span class="sig-paren">(</span>UInt <em>i0</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor7setZeroE4UIntz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets the element at idx to zero. </p>
<p>Calls setZero(Index). </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor7setZeroERK6DomainI4UIntE">
<span id="nupic::SparseTensor::setZero__Domain:UInt:CR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a2a5019339171f0837683731b5570892c"></span>void <code class="descname">setZero</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic6DomainE" title="nupic::Domain">Domain</a>&lt;UInt&gt; &amp;<em>dom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor7setZeroERK6DomainI4UIntE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets to zero all the elements in <a class="reference internal" href="#nupic.coreclassnupic_1_1_domain"><span class="std std-ref">Domain</span></a> dom. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dom</span></code>: [Domain&lt;UInt&gt;] the domain to set to zero </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor10setNonZeroERK5IndexRK5Float">
<span id="nupic::SparseTensor::setNonZero__IndexCR.FloatCR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1abbddd070687f02e1ec57bc7246b7247a"></span>void <code class="descname">setNonZero</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>idx</em>, <em class="property">const</em> Float &amp;<em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor10setNonZeroERK5IndexRK5Float" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets element at idx to val, where |val| &gt; nupic::Epsilon. </p>
<p>Use if you know what you do: even f(non-zero, non-zero) can be &#8220;zero&#8221;, if it falls below nupic::Epsilon.</p>
<p>Complexity: O(log(number of non-zeros))</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">idx</span></code>: [<a class="reference internal" href="#nupic.coreclassnupic_1_1_index"><span class="std std-ref">Index</span></a>] the index of the element to set to val </li>
<li><code class="docutils literal"><span class="pre">val</span></code>: [Float] the value to set for the element at idx </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor10setNonZeroERK6DomainI4UIntERK5Float">
<span id="nupic::SparseTensor::setNonZero__Domain:UInt:CR.FloatCR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a0ed9c2f89ed63678fdb13435be1bbbd8"></span>void <code class="descname">setNonZero</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic6DomainE" title="nupic::Domain">Domain</a>&lt;UInt&gt; &amp;<em>dom</em>, <em class="property">const</em> Float &amp;<em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor10setNonZeroERK6DomainI4UIntERK5Float" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets all the values inside dom to val. </p>
<p>Works only if |val| &gt; nupic::Epsilon.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dom</span></code>: [Domain&lt;UInt&gt;] the domain inside which to set values </li>
<li><code class="docutils literal"><span class="pre">val</span></code>: [Float] the value to set inside dom </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> binary_functor&gt;</dt>
<dt id="_CPPv2N5nupic12SparseTensor6updateERK5IndexRK5Float14binary_functor">
<span id="nupic::SparseTensor::update__IndexCR.FloatCR.binary_functor"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1af09c16f6137ecf8ad825f83de3438d2e"></span>Float <code class="descname">update</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>idx</em>, <em class="property">const</em> Float &amp;<em>val</em>, binary_functor <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor6updateERK5IndexRK5Float14binary_functor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Updates the value of this tensor at idx in place, using f and val: A[idx] = f(A[idx], val) (val as second argument). </p>
<p>Handles zeros properly.</p>
<p>Complexity: O(log(number of non-zeros)) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor3addERK5IndexRK5Float">
<span id="nupic::SparseTensor::add__IndexCR.FloatCR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a0f8f88d5dd0a00e4543e435f51ec3631"></span>void <code class="descname">add</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>idx</em>, <em class="property">const</em> Float &amp;<em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor3addERK5IndexRK5Float" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>TODO: unit test. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor6setAllERK5Float">
<span id="nupic::SparseTensor::setAll__FloatCR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a8ab08002a8dd3ad2b64b0441eff91e21"></span>void <code class="descname">setAll</code><span class="sig-paren">(</span><em class="property">const</em> Float &amp;<em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor6setAllERK5Float" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets all the values in this tensor to val. </p>
<p>Makes this sparse tensor dense if |val| &gt; nupic::Epsilon. Otherwise, removes all the values in this sparse tensor</p>
<p>Complexity: O(product of bounds) (worst case, if |val| &gt; nupic::Epsilon) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor3getERK5Index">
<span id="nupic::SparseTensor::get__IndexCRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a750b6d4dca9f06ed313fb67eefc7081c"></span>Float <code class="descname">get</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>idx</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor3getERK5Index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the value of the element at idx. </p>
<p>Complexity: O(log(number of non-zeros)) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor3getE4UIntz">
<span id="nupic::SparseTensor::get__UInt.z"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1aa5d7288317c7ba5de12f2af09af303cf"></span><em class="property">const</em> Float <code class="descname">get</code><span class="sig-paren">(</span>UInt <em>i0</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor3getE4UIntz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the value of the element at idx. </p>
<p>Calls get(Index). </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensorclE4UIntz">
<span id="nupic::SparseTensor::call-operator__UInt.zC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1abb17efc45c89c2c48429a248b936ff19"></span><em class="property">const</em> Float <code class="descname">operator()</code><span class="sig-paren">(</span>UInt <em>i0</em>, ...<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensorclE4UIntz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the element at idx. </p>
<p>Calls get(Index). not providing the other one, because we need to control for zero, we can&#8217;t just blindly pass a reference </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor7extractE4UIntRKNSt3setI4UIntEER12SparseTensor">
<span id="nupic::SparseTensor::extract__UInt.std::set:UInt:CR.SparseTensorRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a7a09479d26a9568692bad7f4c784ad24"></span>void <code class="descname">extract</code><span class="sig-paren">(</span>UInt <em>dim</em>, <em class="property">const</em> std::set&lt;UInt&gt; &amp;<em>ind</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a> &amp;<em>B</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor7extractE4UIntRKNSt3setI4UIntEER12SparseTensor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Extract sub-spaces along dimension dim, and put result in B. </p>
<p>Only the non-zeros who dim-th coordinate is in ind are kept and stored in B.</p>
<p>This operation reduces the size of this <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a> along dimension dim to the number of elements in ind. This operation reduces the size of this <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a> along dimension dim to the number of elements in ind. If ind is full, returns this <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a> unmodified. If ind is empty, throws an exception, because I can&#8217;t reduce a <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a> to have a size along any dimension of zero. You need to detect that ind is empty before calling reduce.</p>
<p>Returns the null tensor (not a tensor) if ind is empty, i.e.</p>
<p>dim = 0 indicates that some rows will be removed... </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor6reduceE4UIntRKNSt3setI4UIntEE">
<span id="nupic::SparseTensor::reduce__UInt.std::set:UInt:CR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1acc89e397bd060343123f44164984f0e8"></span>void <code class="descname">reduce</code><span class="sig-paren">(</span>UInt <em>dim</em>, <em class="property">const</em> std::set&lt;UInt&gt; &amp;<em>ind</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor6reduceE4UIntRKNSt3setI4UIntEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>In place (mutating) reduce. </p>
<p>Keeps only the sub-spaces (rows or columns for a matrix) whose coordinate is a member of ind. Reduces the size of the tensor along dimension dim to the size of ind. Yields the null tensor if ind is empty. Does not change the tensor if ind is full.</p>
<p>Examples: S2.reduce(0, set(1, 3)) keeps rows 1 and 3 of the matrix, eliminates the other rows. S2.reduce(1, set(1, 3)) keeps columns 1 and 3 of the matrix, eliminates the other columns. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> IndexB&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor8getSliceERK6DomainI4UIntER12SparseTensorI6IndexB5FloatE">
<span id="nupic::SparseTensor::getSlice__Domain:UInt:CR.SparseTensor:IndexB.Float:RC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1ad1aa2509c9e5992b9ebe59cd70111d67"></span>void <code class="descname">getSlice</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic6DomainE" title="nupic::Domain">Domain</a>&lt;UInt&gt; &amp;<em>range</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor8getSliceERK6DomainI4UIntER12SparseTensorI6IndexB5FloatE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Extract slices or sub-arrays from this tensor, of any dimensions, and within any bounds. </p>
<p>Slices can be of any dimension &lt;= <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor_1a6712936d3ca0b1824aeb768b225f3412"><span class="std std-ref">getRank()</span></a>. Slices are not allocated by this function, so an optional clearYesNo parameter is provided to remove all the existing non-zeros from the slice (B). When the range is not as big as the cartesian product of the bounds of this tensor, a sub-array tensor is extracted.</p>
<p>Examples: If A has dimensions [(0, 10), (0, 20), (0, 30)]<ul class="simple">
<li>slice with <a class="reference internal" href="#nupic.coreclassnupic_1_1_domain"><span class="std std-ref">Domain</span></a> = ((0, 0, 0), (10, 20, 30)) gives A</li>
<li>slice with <a class="reference internal" href="#nupic.coreclassnupic_1_1_domain"><span class="std std-ref">Domain</span></a> = ((0, 0, 10), (10, 20, 30)) gives the subarray of A reduced to indices 10 to 29 along the third dimension</li>
<li>slice with <a class="reference internal" href="#nupic.coreclassnupic_1_1_domain"><span class="std std-ref">Domain</span></a> = ((0, 0, 10), (10, 20, 10)) gives the matrix (0,10) by (0, 20) obtained when the third index is blocked to 10.</li>
</ul>
</p>
<p>Complexity: O(number of non-zeros in slice)</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">range</span></code>: [Domain&lt;UInt&gt;] the range to extract from this tensor. </li>
<li><code class="docutils literal"><span class="pre">B</span></code>: [SparseTensor&lt;IndexB, Float&gt;] the resulting slice </li>
<li><code class="docutils literal"><span class="pre">clearYesNo</span></code>: [bool] whether to clear B before slicing or not </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor6isZeroERK5Index">
<span id="nupic::SparseTensor::isZero__IndexCRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1aab6fb254f14c52d9e92c3003e9ef13a1"></span>bool <code class="descname">isZero</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>idx</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor6isZeroERK5Index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether the element at idx is zero or not. </p>
<p>Complexity: O(log(number of non-zeros)) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor6isZeroE4UIntz">
<span id="nupic::SparseTensor::isZero__UInt.zC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a9be265f5ca93de38dd05087406fdfd38"></span>bool <code class="descname">isZero</code><span class="sig-paren">(</span>UInt <em>i0</em>, ...<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor6isZeroE4UIntz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether the element at idx is zero or not. </p>
<p>Calls isZero(Index). </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> OutIter&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor7toDenseE7OutIter">
<span id="nupic::SparseTensor::toDense__OutIterC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a544293a53db5eb2b6a2bb72b5456b9b3"></span>void <code class="descname">toDense</code><span class="sig-paren">(</span>OutIter <em>array</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor7toDenseE7OutIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies this sparse tensor to the given array of Floats. </p>
<p>Sets the array to zero first, then copies only the non-zeros.</p>
<p>Complexity: O(number of non-zeros) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InIter&gt;</dt>
<dt id="_CPPv2N5nupic12SparseTensor9fromDenseE6InIterb">
<span id="nupic::SparseTensor::fromDense__InIter.b"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a792bb4f73327e6375bf6d9436dd68281"></span>void <code class="descname">fromDense</code><span class="sig-paren">(</span>InIter <em>array</em>, bool <em>clearYesNo</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor9fromDenseE6InIterb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the non-zeros from array into this sparse tensor. </p>
<p>Clears this tensor first if the flag is true.</p>
<p>Complexity: O(size * log(size)) ?? </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> OutIter&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor8toIdxValE7OutIter">
<span id="nupic::SparseTensor::toIdxVal__OutIterC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1abea397bcea8d0d189e55a44c7715f8e6"></span>void <code class="descname">toIdxVal</code><span class="sig-paren">(</span>OutIter <em>iv</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor8toIdxValE7OutIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the non-zeros from this tensor to the given output iterator. </p>
<p>Complexity: O(number of non-zeros) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InIter&gt;</dt>
<dt id="_CPPv2N5nupic12SparseTensor10fromIdxValERK4UInt6InIterb">
<span id="nupic::SparseTensor::fromIdxVal__UIntCR.InIter.b"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a91d02cb1c41cf61d885debdf38b5d3fe"></span>void <code class="descname">fromIdxVal</code><span class="sig-paren">(</span><em class="property">const</em> UInt &amp;<em>nz</em>, InIter <em>iv</em>, bool <em>clearYesNo</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor10fromIdxValERK4UInt6InIterb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the values from the input iterator into this sparse tensor. </p>
<p>Clear this tensor first, optionally. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InIter&gt;</dt>
<dt id="_CPPv2N5nupic12SparseTensor13fromIdxVal_nzERK4UInt6InIterb">
<span id="nupic::SparseTensor::fromIdxVal_nz__UIntCR.InIter.b"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a1e3638ca79e8a7a799eb54e25a79d963"></span>void <code class="descname">fromIdxVal_nz</code><span class="sig-paren">(</span><em class="property">const</em> UInt &amp;<em>nz</em>, InIter <em>iv</em>, bool <em>clearYesNo</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor13fromIdxVal_nzERK4UInt6InIterb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the values from the input iterator into this sparse tensor, assuming that only non-zeros are passed. </p>
<p>Clear this tensor first, optionally. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InIter, <em class="property">typename</em> binary_functor&gt;</dt>
<dt id="_CPPv2N5nupic12SparseTensor16updateFromIdxValERK4UInt6InIter14binary_functor">
<span id="nupic::SparseTensor::updateFromIdxVal__UIntCR.InIter.binary_functor"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a9086c83b91e6307634f6b817da3b8963"></span>void <code class="descname">updateFromIdxVal</code><span class="sig-paren">(</span><em class="property">const</em> UInt &amp;<em>nz</em>, InIter <em>iv</em>, binary_functor <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor16updateFromIdxValERK4UInt6InIter14binary_functor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Updates some of the values in this sparse tensor, the indices and values to use for the update being passed in the input iterator. </p>
<p>Uses binary functor f to carry out the update. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor8toStreamERNSt7ostreamE">
<span id="nupic::SparseTensor::toStream__osRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a3c76d014b6203035f351ef2032df1d74"></span>void <code class="descname">toStream</code><span class="sig-paren">(</span>std::ostream &amp;<em>outStream</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor8toStreamERNSt7ostreamE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Outputs the non-zeros of this sparse tensor to a stream. </p>
<p>Only non-zeros are put to the stream. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor10fromStreamERNSt7istreamE">
<span id="nupic::SparseTensor::fromStream__isR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a8110838cbadab1dfd2151a90f603c378"></span>void <code class="descname">fromStream</code><span class="sig-paren">(</span>std::istream &amp;<em>inStream</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor10fromStreamERNSt7istreamE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reads values for this sparse tensor from a stream. </p>
<p>Works even if the stream contains zeros (calls set). </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor5beginEv">
<span id="nupic::SparseTensor::begin"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1aa44901a2cce3bf3f6075d0831ea2d013"></span>iterator <code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor5beginEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns an iterator to the beginning of the non-zeros in this tensor. </p>
<p>Iterator iterate only over the non-zeros. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor3endEv">
<span id="nupic::SparseTensor::end"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a96880bcc67f8e905dcbfcb31d3e65a0b"></span>iterator <code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor3endEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns an iterator to one past the end of the non-zeros in this tensor. </p>
<p>Iterator iterate only over the non-zeros. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor5beginEv">
<span id="nupic::SparseTensor::beginC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a64e7ff504d7da05bb585660406785ebd"></span>const_iterator <code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor5beginEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a const iterator to the beginning of the non-zeros in this tensor. </p>
<p>Iterator iterate only over the non-zeros. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor3endEv">
<span id="nupic::SparseTensor::endC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1ab5600afadef6672a73e4f41d8d1447f1"></span>const_iterator <code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor3endEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a const iterator to one past the end of the non-zeros in this tensor. </p>
<p>Iterator iterate only over the non-zeros. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor7permuteERK5Index">
<span id="nupic::SparseTensor::permute__IndexCR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a5f37687c109398389eee29e22595e78c"></span>void <code class="descname">permute</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>ind</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor7permuteERK5Index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Permute the dimensions of each element of this tensor. </p>
<p>Complexity: O(number of non-zeros) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor6resizeERK5Index">
<span id="nupic::SparseTensor::resize__IndexCR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a52ad9e0242a80a6c0997e9eaf169e8b1"></span>void <code class="descname">resize</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a> &amp;<em>newBounds</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor6resizeERK5Index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Change the bounds of this tensor, while keeping the dimensionality. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> IndexB&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor7reshapeER12SparseTensorI6IndexB5FloatE">
<span id="nupic::SparseTensor::reshape__SparseTensor:IndexB.Float:RC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a82c1fa97036d6eee2845516fcffe7b3f"></span>void <code class="descname">reshape</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor7reshapeER12SparseTensorI6IndexB5FloatE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Produces a tensor B that has the same non-zeros as this one but the given dimensions (the dimensions of B). </p>
<p>Tensor B needs to provide as much storage as this sparse tensor.</p>
<p>Complexity: O(number of non-zeros)</p>
<p>B [SparseTensor&lt;IndexB, Float&gt;] the target sparse tensor </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor15nz_intersectionERK12SparseTensorRNSt6vectorI5IndexEE">
<span id="nupic::SparseTensor::nz_intersection__SparseTensorCR.std::vector:Index:RC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1aca53213c84d9b0a800f3e9ac293cf506"></span>void <code class="descname">nz_intersection</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a> &amp;<em>B</em>, std::vector&lt;<a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a>&gt; &amp;<em>inter</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor15nz_intersectionERK12SparseTensorRNSt6vectorI5IndexEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the set of indices where this tensor and B have common non-zeros, when A and B have the same rank. </p>
<p>Complexity: O(smaller number of non-zeros between this and B) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> IndexB&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor15nz_intersectionERK6IndexBRK12SparseTensorI6IndexB5FloatER8NonZerosI5Index6IndexBE">
<span id="nupic::SparseTensor::nz_intersection__IndexBCR.SparseTensor:IndexB.Float:CR.NonZeros:Index.IndexB:RC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a41ee53d8bb023474c15e8ddb8d49ea2f"></span>void <code class="descname">nz_intersection</code><span class="sig-paren">(</span><em class="property">const</em> IndexB &amp;<em>dims</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensor8NonZerosE" title="nupic::SparseTensor::NonZeros">NonZeros</a>&lt;<a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a>, IndexB&gt; &amp;<em>inter</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor15nz_intersectionERK6IndexBRK12SparseTensorI6IndexB5FloatER8NonZerosI5Index6IndexBE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the set of indices where the projection of this tensor on dims and B have common non-zeros. </p>
<p>A and B have different Ranks.</p>
<p>Complexity: O(number of non-zeros) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor8nz_unionERK12SparseTensorRNSt6vectorI5IndexEE">
<span id="nupic::SparseTensor::nz_union__SparseTensorCR.std::vector:Index:RC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a4189d250683725fd85237eb658170407"></span>void <code class="descname">nz_union</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a> &amp;<em>B</em>, std::vector&lt;<a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a>&gt; &amp;<em>u</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor8nz_unionERK12SparseTensorRNSt6vectorI5IndexEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the set of indices where this tensor or B have a non-zero. </p>
<p>Complexity: O(sum of number of non-zeros in this and B) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> IndexB&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor8nz_unionERK6IndexBRK12SparseTensorI6IndexB5FloatER8NonZerosI5Index6IndexBE">
<span id="nupic::SparseTensor::nz_union__IndexBCR.SparseTensor:IndexB.Float:CR.NonZeros:Index.IndexB:RC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1ad88c94a233e689a9cdca909bc7e67c2a"></span>void <code class="descname">nz_union</code><span class="sig-paren">(</span><em class="property">const</em> IndexB &amp;<em>dims</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensor8NonZerosE" title="nupic::SparseTensor::NonZeros">NonZeros</a>&lt;<a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a>, IndexB&gt; &amp;<em>u</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor8nz_unionERK6IndexBRK12SparseTensorI6IndexB5FloatER8NonZerosI5Index6IndexBE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the set of indices where the projection of this tensor on dims and B have at least one non-zero. </p>
<p>Complexity: O(product of bounds)</p>
<p>Note: wish I could find a faster way to compute that union </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> unary_function&gt;</dt>
<dt id="_CPPv2N5nupic12SparseTensor16element_apply_nzE14unary_function">
<span id="nupic::SparseTensor::element_apply_nz__unary_function"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a51d5661f54151aa6fd8f80c7fa0354fd"></span>void <code class="descname">element_apply_nz</code><span class="sig-paren">(</span>unary_function <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor16element_apply_nzE14unary_function" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the unary functor f to each non-zero element in this sparse tensor, assuming that no new non-zero is introduced. </p>
<p>This works for scaling, for example, if the scaling value is not zero.</p>
<p>: this is pretty dangerous, since it doesn&#8217;t check that f introduces new zeros!!! </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> unary_function&gt;</dt>
<dt id="_CPPv2N5nupic12SparseTensor18element_apply_fastE14unary_function">
<span id="nupic::SparseTensor::element_apply_fast__unary_function"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1ac724afbc80407bce61bb125caf2a5172"></span>void <code class="descname">element_apply_fast</code><span class="sig-paren">(</span>unary_function <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor18element_apply_fastE14unary_function" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the unary functor f to each non-zero element in this tensor: </p>
<p>A[i] = f(A[i]), with f(0) == 0.</p>
<p>Assumes (and checks) that f(0) == 0. The non-zeros can change. New non-zeros can be introduced, but this function iterates on the non-zeros only. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> unary_functor&gt;</dt>
<dt id="_CPPv2N5nupic12SparseTensor13element_applyE13unary_functor">
<span id="nupic::SparseTensor::element_apply__unary_functor"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a6af5c6ae80d71e10314b71bb482389cd"></span>void <code class="descname">element_apply</code><span class="sig-paren">(</span>unary_functor <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor13element_applyE13unary_functor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the unary functor f to all elements in this tensor, as if it were a dense tensor. </p>
<p>This is useful when f(0) != 0, but it is slow because it doesn&#8217;t take advantage of the sparsity.</p>
<p>A[i] = f(A[i])</p>
<p>Complexity: O(product of the bounds) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> binary_functor&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor18element_apply_fastERK12SparseTensorR12SparseTensor14binary_functorb">
<span id="nupic::SparseTensor::element_apply_fast__SparseTensorCR.SparseTensorR.binary_functor.bC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1ab78137b1b78838ddce9167f58455fbca"></span>void <code class="descname">element_apply_fast</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a> &amp;<em>B</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a> &amp;<em>C</em>, binary_functor <em>f</em>, bool <em>clearYesNo</em> = true<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor18element_apply_fastERK12SparseTensorR12SparseTensor14binary_functorb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the binary functor f to couple of elements from this tensor and tensor B, at the same element, where no element of the couple is zero. </p>
<p>The result is stored in tensor C.</p>
<p>C[i] = f(A[i], B[i]), where A[i] != 0 AND B[i] != 0.</p>
<p>This works for f = multiplication, where f(x, 0) == f(0, x) == 0, for all x. It doesn&#8217;t work for addition.</p>
<p>Complexity: O(smaller number of non-zeros between this and B) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> binary_functor&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor16element_apply_nzERK12SparseTensorR12SparseTensor14binary_functorb">
<span id="nupic::SparseTensor::element_apply_nz__SparseTensorCR.SparseTensorR.binary_functor.bC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a3705f01ca9aaf67720c7d33c8d95dc00"></span>void <code class="descname">element_apply_nz</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a> &amp;<em>B</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a> &amp;<em>C</em>, binary_functor <em>f</em>, bool <em>clearYesNo</em> = true<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor16element_apply_nzERK12SparseTensorR12SparseTensor14binary_functorb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the binary functor f to couple of elements from this tensor and tensor B, at the same index, assuming that f(0, 0) == 0. </p>
<p>The result is stored in tensor C.</p>
<p>C[i] = f(A[i], B[i]), where A[i] != 0 OR B[i] != 0</p>
<p>This works for f = multiplication, and f = addition. It does not work if f(0, 0) != 0.</p>
<p>Complexity: O(sum of number of non-zeros between this and B) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> binary_functor&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor13element_applyERK12SparseTensorR12SparseTensor14binary_functor">
<span id="nupic::SparseTensor::element_apply__SparseTensorCR.SparseTensorR.binary_functorC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a06e9a809655f90b4507cee34a644fb2a"></span>void <code class="descname">element_apply</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a> &amp;<em>B</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a> &amp;<em>C</em>, binary_functor <em>f</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor13element_applyERK12SparseTensorR12SparseTensor14binary_functor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the binary functor f to couple of elements from this tensor and tensor B, at the same index, without assuming anything on f. </p>
<p>The result is stored in tensor C.</p>
<p>C[i] = f(A[i], B[i])</p>
<p>This works in all cases, even if f(0, 0) != 0. It does not take advantage of the sparsity.</p>
<p>Complexity: O(product of the bounds) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> IndexB, <em class="property">typename</em> binary_functor&gt;</dt>
<dt id="_CPPv2N5nupic12SparseTensor17factor_apply_fastERK6IndexBRK12SparseTensorI6IndexB5FloatE14binary_functor">
<span id="nupic::SparseTensor::factor_apply_fast__IndexBCR.SparseTensor:IndexB.Float:CR.binary_functor"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a8dd86e05b587e99fa36696d1de912c22"></span>void <code class="descname">factor_apply_fast</code><span class="sig-paren">(</span><em class="property">const</em> IndexB &amp;<em>dims</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em>, binary_functor <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor17factor_apply_fastERK6IndexBRK12SparseTensorI6IndexB5FloatE14binary_functor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>In place factor apply (mutating) </p>
<p>A[i] = f(A[i], B[j]), where j = projection of i on dims, and A[i] != 0 AND B[j] != 0.</p>
<p>This works for multiplication, but not for addition, and not if f(0, 0) == 0.</p>
<p>Complexity: O(smaller number of non-zeros between this and B) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> IndexB, <em class="property">typename</em> binary_functor&gt;</dt>
<dt id="_CPPv2N5nupic12SparseTensor15factor_apply_nzERK6IndexBRK12SparseTensorI6IndexB5FloatE14binary_functor">
<span id="nupic::SparseTensor::factor_apply_nz__IndexBCR.SparseTensor:IndexB.Float:CR.binary_functor"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a94281b0c2c97d219b5fa3df1879dd0d1"></span>void <code class="descname">factor_apply_nz</code><span class="sig-paren">(</span><em class="property">const</em> IndexB &amp;<em>dims</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em>, binary_functor <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor15factor_apply_nzERK6IndexBRK12SparseTensorI6IndexB5FloatE14binary_functor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>In place factor apply on non-zeros (mutating). </p>
<p>Works for addition and multiplication. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> IndexB, <em class="property">typename</em> binary_functor&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor17factor_apply_fastERK6IndexBRK12SparseTensorI6IndexB5FloatER12SparseTensorI5Index5FloatE14binary_functorb">
<span id="nupic::SparseTensor::factor_apply_fast__IndexBCR.SparseTensor:IndexB.Float:CR.SparseTensor:Index.Float:R.binary_functor.bC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1aed60f35df3261733b0585086506da5b1"></span>void <code class="descname">factor_apply_fast</code><span class="sig-paren">(</span><em class="property">const</em> IndexB &amp;<em>dims</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;<a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a>, Float&gt; &amp;<em>C</em>, binary_functor <em>f</em>, bool <em>clearYesNo</em> = true<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor17factor_apply_fastERK6IndexBRK12SparseTensorI6IndexB5FloatER12SparseTensorI5Index5FloatE14binary_functorb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Binary factor apply (non-mutating) </p>
<p>C[i] = f(A[i], B[j]), where j = projection of i on dims, and A[i] != 0 AND B[j] != 0.</p>
<p>This works for multiplication, but not for addition, and not if f(0, 0) == 0.</p>
<p>Complexity: O(smaller number of non-zeros between this and B) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> IndexB, <em class="property">typename</em> binary_functor&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor15factor_apply_nzERK6IndexBRK12SparseTensorI6IndexB5FloatER12SparseTensorI5Index5FloatE14binary_functorb">
<span id="nupic::SparseTensor::factor_apply_nz__IndexBCR.SparseTensor:IndexB.Float:CR.SparseTensor:Index.Float:R.binary_functor.bC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a9c085fd7e36674fafc693f50da92d78a"></span>void <code class="descname">factor_apply_nz</code><span class="sig-paren">(</span><em class="property">const</em> IndexB &amp;<em>dims</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;<a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a>, Float&gt; &amp;<em>C</em>, binary_functor <em>f</em>, bool <em>clearYesNo</em> = true<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor15factor_apply_nzERK6IndexBRK12SparseTensorI6IndexB5FloatER12SparseTensorI5Index5FloatE14binary_functorb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>C[i] = f(A[i], B[j]), where j = projection of i on dims, and A[i] != 0 OR B[j] != 0. </p>
<p>This works for addition, but not if f(0, 0) != 0.</p>
<p>Complexity: O(sum of number of non-zeros between this and B) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> IndexB, <em class="property">typename</em> binary_functor&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor12factor_applyERK6IndexBRK12SparseTensorI6IndexB5FloatER12SparseTensorI5Index5FloatE14binary_functor">
<span id="nupic::SparseTensor::factor_apply__IndexBCR.SparseTensor:IndexB.Float:CR.SparseTensor:Index.Float:R.binary_functorC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a5be5e69ed40bc31417e5537cca62fa05"></span>void <code class="descname">factor_apply</code><span class="sig-paren">(</span><em class="property">const</em> IndexB &amp;<em>dims</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;<a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a>, Float&gt; &amp;<em>C</em>, binary_functor <em>f</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor12factor_applyERK6IndexBRK12SparseTensorI6IndexB5FloatER12SparseTensorI5Index5FloatE14binary_functor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>C[i] = f(A[i], B[j]), where j = projection of i on dims. </p>
<p>There is no restriction on f, it works even if f(0, 0) != 0. Doesn&#8217;t take advantage of the sparsity.</p>
<p>Complexity: O(product of bounds) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> Index2, <em class="property">typename</em> IndexB, <em class="property">typename</em> binary_functor&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor13accumulate_nzERK6Index2R12SparseTensorI6IndexB5FloatE14binary_functorRK5Float">
<span id="nupic::SparseTensor::accumulate_nz__Index2CR.SparseTensor:IndexB.Float:R.binary_functor.FloatCRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a8bbbd967070cc93cbafd29017d4aeb68"></span>void <code class="descname">accumulate_nz</code><span class="sig-paren">(</span><em class="property">const</em> Index2 &amp;<em>dims</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em>, binary_functor <em>f</em>, <em class="property">const</em> Float &amp;<em>init</em> = 0<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor13accumulate_nzERK6Index2R12SparseTensorI6IndexB5FloatE14binary_functorRK5Float" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>C[j] = f(C[j], A[i]), where j = projection of i on L dims. </p>
<p>Works only on the non-zeros, assumes f(0, 0) = 0 ?? Use this version AND init = 1 for multiplication.</p>
<p>Complexity: O(number of non-zeros)</p>
<p>Examples: If s2 is a 2D sparse tensor with dimensions (4, 5), and s1 a 1D sparse tensor (vector), then:<ul class="simple">
<li>accumulate_nz(I1(0), s1, plus&lt;float&gt;(), 0) accumulates vertically, and s1 has size 5.</li>
<li>accumulate_nz(I1(1), s1, plus&lt;float&gt;(), 0) accumulates horizontally, and s1 has size 4. </li>
</ul>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> Index2, <em class="property">typename</em> IndexB, <em class="property">typename</em> binary_functor&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor10accumulateERK6Index2R12SparseTensorI6IndexB5FloatE14binary_functorRK5Float">
<span id="nupic::SparseTensor::accumulate__Index2CR.SparseTensor:IndexB.Float:R.binary_functor.FloatCRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1ad90ee4088c3c017dbf4bc1ac04ff61b1"></span>void <code class="descname">accumulate</code><span class="sig-paren">(</span><em class="property">const</em> Index2 &amp;<em>dims</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em>, binary_functor <em>f</em>, <em class="property">const</em> Float &amp;<em>init</em> = 0<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor10accumulateERK6Index2R12SparseTensorI6IndexB5FloatE14binary_functorRK5Float" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>B[j] = f(B[j], A[i]), where j = projection of i on L dims. </p>
<p>Works on all the values, including the zeros, so it is inappropriate for multiplication, since the zeros will produce zeros in the output, even if init != 0.</p>
<p>No restriction on f, doesn&#8217;t take advantage of the sparsity.</p>
<p>Complexity: O(product of bounds) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> Index2&gt;</dt>
<dt id="_CPPv2N5nupic12SparseTensor9normalizeERK6Index2">
<span id="nupic::SparseTensor::normalize__Index2CR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a5fe060f16cabca2d33f5974a29101f35"></span>void <code class="descname">normalize</code><span class="sig-paren">(</span><em class="property">const</em> Index2 &amp;<em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor9normalizeERK6Index2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>In place (mutating) normalize. </p>
<p>Examples: S2.normalize(I1(UInt(0))): normalize vertically S2.normalize(I1(UInt(1))): normalize horizontally </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> IndexB, <em class="property">typename</em> IndexC, <em class="property">typename</em> binary_functor&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor16outer_product_nzERK12SparseTensorI6IndexB5FloatER12SparseTensorI6IndexC5FloatE14binary_functor">
<span id="nupic::SparseTensor::outer_product_nz__SparseTensor:IndexB.Float:CR.SparseTensor:IndexC.Float:R.binary_functorC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a7ad49107f858fec7c631985c5f37a7ea"></span>void <code class="descname">outer_product_nz</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexC, Float&gt; &amp;<em>C</em>, binary_functor <em>f</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor16outer_product_nzERK12SparseTensorI6IndexB5FloatER12SparseTensorI6IndexC5FloatE14binary_functor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the outer product of this sparse tensor and B, puts the result in C: </p>
<p>C[i.j] = f(A[i], B[j]). Cijkpq = f(Aijk, Bpq)</p>
<p>Works only the non-zeros, assumes f(0, 0) = f(x, 0) = f(0, x) = 0. Works for multiplication, but not for addition.</p>
<p>Complexity: O(square of total number of non-zeros) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> IndexB, <em class="property">typename</em> IndexC, <em class="property">typename</em> binary_functor&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor13outer_productERK12SparseTensorI6IndexB5FloatER12SparseTensorI6IndexC5FloatE14binary_functor">
<span id="nupic::SparseTensor::outer_product__SparseTensor:IndexB.Float:CR.SparseTensor:IndexC.Float:R.binary_functorC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a2217eb53c3b0a77d48f639f4c794b16a"></span>void <code class="descname">outer_product</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexC, Float&gt; &amp;<em>C</em>, binary_functor <em>f</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor13outer_productERK12SparseTensorI6IndexB5FloatER12SparseTensorI6IndexC5FloatE14binary_functor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the outer product of this sparse tensor and B, puts the result in C: </p>
<p>C[i.j] = f(A[i], B[j]).</p>
<p>Doesn&#8217;t assume anything on f, works in all cases, but remarkably slow.</p>
<p>Complexity: O(square of product of bounds) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> IndexB, <em class="property">typename</em> binary_functor&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor11contract_nzEK4UIntK4UIntR12SparseTensorI6IndexB5FloatE14binary_functorRK5Float">
<span id="nupic::SparseTensor::contract_nz__UIntC.UIntC.SparseTensor:IndexB.Float:R.binary_functor.FloatCRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1abba59d2fa661f7048a42115f58a09c84"></span>void <code class="descname">contract_nz</code><span class="sig-paren">(</span><em class="property">const</em> UInt <em>dim1</em>, <em class="property">const</em> UInt <em>dim2</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em>, binary_functor <em>f</em>, <em class="property">const</em> Float &amp;<em>init</em> = 0<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor11contract_nzEK4UIntK4UIntR12SparseTensorI6IndexB5FloatE14binary_functorRK5Float" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the contraction of this sparse tensor along the two given dimensions: </p>
<p>B[ikl...] = accumulate using f(j, A[ijkl...j...]), where j shows at positions dim1 and dim2 of A. Cikq = f(Aiuk, Buq)</p>
<p>Works only on the non-zeros, assumes f(0, 0) = 0 ??</p>
<p>Complexity: O(number of non-zeros) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> IndexB, <em class="property">typename</em> binary_functor&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor8contractEK4UIntK4UIntR12SparseTensorI6IndexB5FloatE14binary_functorRK5Float">
<span id="nupic::SparseTensor::contract__UIntC.UIntC.SparseTensor:IndexB.Float:R.binary_functor.FloatCRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a582b020eeee3ff87620859b979768bd2"></span>void <code class="descname">contract</code><span class="sig-paren">(</span><em class="property">const</em> UInt <em>dim1</em>, <em class="property">const</em> UInt <em>dim2</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em>, binary_functor <em>f</em>, <em class="property">const</em> Float &amp;<em>init</em> = 0<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor8contractEK4UIntK4UIntR12SparseTensorI6IndexB5FloatE14binary_functorRK5Float" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the contraction of this sparse tensor along the two given dimensions: </p>
<p>B[ikl...] = accumulate using f(j, A[ijkl...j...]), where j shows at positions dim1 and dim2 of A.</p>
<p>No assumption on f.</p>
<p>Complexity: O(product of bounds) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> IndexB, <em class="property">typename</em> IndexC, <em class="property">typename</em> binary_functor1, <em class="property">typename</em> binary_functor2&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor16inner_product_nzEK4UIntK4UIntRK12SparseTensorI6IndexB5FloatER12SparseTensorI6IndexC5FloatE15binary_functor115binary_functor2RK5Float">
<span id="nupic::SparseTensor::inner_product_nz__UIntC.UIntC.SparseTensor:IndexB.Float:CR.SparseTensor:IndexC.Float:R.binary_functor1.binary_functor2.FloatCRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a97f84bb6cc993c94d65ec0689a50d318"></span>void <code class="descname">inner_product_nz</code><span class="sig-paren">(</span><em class="property">const</em> UInt <em>dim1</em>, <em class="property">const</em> UInt <em>dim2</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexC, Float&gt; &amp;<em>C</em>, binary_functor1 <em>f</em>, binary_functor2 <em>g</em>, <em class="property">const</em> Float &amp;<em>init</em> = 0<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor16inner_product_nzEK4UIntK4UIntRK12SparseTensorI6IndexB5FloatER12SparseTensorI6IndexC5FloatE15binary_functor115binary_functor2RK5Float" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the inner product of this sparse tensor and B, put the result in C: </p>
<p>C[k] = accumulate using g(product using f of B[i], C[j])</p>
<p>Works only on the non-zeros.</p>
<p>Complexity: O(square of number of non-zeros in one dim) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> IndexB, <em class="property">typename</em> IndexC, <em class="property">typename</em> binary_functor1, <em class="property">typename</em> binary_functor2&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor13inner_productEK4UIntK4UIntRK12SparseTensorI6IndexB5FloatER12SparseTensorI6IndexC5FloatE15binary_functor115binary_functor2RK5Float">
<span id="nupic::SparseTensor::inner_product__UIntC.UIntC.SparseTensor:IndexB.Float:CR.SparseTensor:IndexC.Float:R.binary_functor1.binary_functor2.FloatCRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a3930e0204b1480e4e2e696e5e87841cc"></span>void <code class="descname">inner_product</code><span class="sig-paren">(</span><em class="property">const</em> UInt <em>dim1</em>, <em class="property">const</em> UInt <em>dim2</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexC, Float&gt; &amp;<em>C</em>, binary_functor1 <em>f</em>, binary_functor2 <em>g</em>, <em class="property">const</em> Float &amp;<em>init</em> = 0<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor13inner_productEK4UIntK4UIntRK12SparseTensorI6IndexB5FloatER12SparseTensorI6IndexC5FloatE15binary_functor115binary_functor2RK5Float" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the inner product of this sparse tensor and B, put the result in C: </p>
<p>C[k] = accumulate using g(product using f of B[i], C[j]) Aijk, Bpq, i, p Tijkpq = f(Aijk, Bpq) Cikq = g(Tiukuq)</p>
<p>Complexity: O( ?? ) </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> Index1A, <em class="property">typename</em> IndexB, <em class="property">typename</em> IndexC, <em class="property">typename</em> binary_functor1, <em class="property">typename</em> binary_functor2&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor8product3ERK7Index1ARK7Index1ARK12SparseTensorI6IndexB5FloatER12SparseTensorI6IndexC5FloatE15binary_functor1">
<span id="nupic::SparseTensor::product3__Index1ACR.Index1ACR.SparseTensor:IndexB.Float:CR.SparseTensor:IndexC.Float:R.binary_functor1C"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a74882c36659b3899ed871e52c314d89a"></span>void <code class="descname">product3</code><span class="sig-paren">(</span><em class="property">const</em> Index1A &amp;<em>dimsA</em>, <em class="property">const</em> Index1A &amp;<em>dimsB</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexC, Float&gt; &amp;<em>C</em>, binary_functor1 <em>f</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor8product3ERK7Index1ARK7Index1ARK12SparseTensorI6IndexB5FloatER12SparseTensorI6IndexC5FloatE15binary_functor1" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Another type of product. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor5printERNSt7ostreamE">
<span id="nupic::SparseTensor::print__osRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a69cd48797397cf9b8371481a87c7f9c1"></span>void <code class="descname">print</code><span class="sig-paren">(</span>std::ostream &amp;<em>outStream</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor5printERNSt7ostreamE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Prints out this tensor to a stream. </p>
<p>There are special formats for dim 1, 2 and 3, and beyond that only the non-zeros are printed out, with their indices. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> Index2, <em class="property">typename</em> IndexB&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor3maxERK6Index2R12SparseTensorI6IndexB5FloatE">
<span id="nupic::SparseTensor::max__Index2CR.SparseTensor:IndexB.Float:RC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a47614e6ec54c6da3425c050a767cb59d"></span>void <code class="descname">max</code><span class="sig-paren">(</span><em class="property">const</em> Index2 &amp;<em>dims</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor3maxERK6Index2R12SparseTensorI6IndexB5FloatE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find the max of some sub-space of this sparse tensor. </p>
<p>Complexity: O(number of non-zeros)</p>
<p>Examples: If s2 is a 2D sparse tensor of size (4, 5), and s1 a 1D, then:<ul class="simple">
<li>s2.max(I1(0), s1) finds the max of each column of s2 and puts it in the corresponding element of s1. s1 has size 5.</li>
<li>s2.max(I1(1), s1) finds the max of each row of s2 and puts it in the correspondin element of s1. s1 has size 4. </li>
</ul>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor3maxEv">
<span id="nupic::SparseTensor::maxC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a53538629eceda03eec34aedfb7043a6c"></span><em class="property">const</em> std::pair&lt;<a class="reference internal" href="#_CPPv2N5nupic5IndexE" title="nupic::Index">Index</a>, Float&gt; <code class="descname">max</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor3maxEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the max of this sparse tensor, and the index of this min. </p>
<p>This funcion needed because <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a> doesn&#8217;t specialize to a scalar properly. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor3sumEv">
<span id="nupic::SparseTensor::sumC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1ae321568f79d6700ab6ee0f3bf7073155"></span><em class="property">const</em> Float <code class="descname">sum</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor3sumEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the sum of all the non-zeros in this sparse tensor. </p>
<p>This funcion needed because <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor"><span class="std std-ref">SparseTensor</span></a> doesn&#8217;t specialize to a scalar properly. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> Index2, <em class="property">typename</em> IndexB&gt;</dt>
<dt id="_CPPv2NK5nupic12SparseTensor3sumERK6Index2R12SparseTensorI6IndexB5FloatE">
<span id="nupic::SparseTensor::sum__Index2CR.SparseTensor:IndexB.Float:RC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a13524dbe676e55094b28abbab4068992"></span>void <code class="descname">sum</code><span class="sig-paren">(</span><em class="property">const</em> Index2 &amp;<em>dims</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a>&lt;IndexB, Float&gt; &amp;<em>B</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor3sumERK6Index2R12SparseTensorI6IndexB5FloatE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wrapper for accumulate with plus. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor8addSliceE4UInt4UInt4UInt">
<span id="nupic::SparseTensor::addSlice__UInt.UInt.UInt"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1aacacf79d0accdaf884fe4de71340431e"></span>void <code class="descname">addSlice</code><span class="sig-paren">(</span>UInt <em>which</em>, UInt <em>src</em>, UInt <em>dst</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor8addSliceE4UInt4UInt4UInt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Adds a slice to another. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor4axbyERK5FloatRK12SparseTensorRK5FloatR12SparseTensor">
<span id="nupic::SparseTensor::axby__FloatCR.SparseTensorCR.FloatCR.SparseTensorRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a95462738570986f59857b0449b4e99fa"></span>void <code class="descname">axby</code><span class="sig-paren">(</span><em class="property">const</em> Float &amp;<em>a</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a> &amp;<em>B</em>, <em class="property">const</em> Float &amp;<em>b</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a> &amp;<em>C</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor4axbyERK5FloatRK12SparseTensorRK5FloatR12SparseTensor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Adds two sparse tensors of the same rank and dimensions. </p>
<p>This is an element-wise addition. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor8multiplyERK5Float">
<span id="nupic::SparseTensor::multiply__FloatCR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a7699233fa57004819c6ccf03c8f538b7"></span>void <code class="descname">multiply</code><span class="sig-paren">(</span><em class="property">const</em> Float &amp;<em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor8multiplyERK5Float" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Scales this sparse tensor by an arbitrary scalar a. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5nupic12SparseTensor8multiplyERK5FloatR12SparseTensor">
<span id="nupic::SparseTensor::multiply__FloatCR.SparseTensorRC"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1ab591df297fe920dab5fad20a71c8a05d"></span>void <code class="descname">multiply</code><span class="sig-paren">(</span><em class="property">const</em> Float &amp;<em>a</em>, <a class="reference internal" href="#_CPPv2N5nupic12SparseTensorE" title="nupic::SparseTensor">SparseTensor</a> &amp;<em>B</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5nupic12SparseTensor8multiplyERK5FloatR12SparseTensor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Scales this sparse tensor and put the result in B, leaving this spare tensor unchanged. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5nupic12SparseTensor9normalizeERK5Float">
<span id="nupic::SparseTensor::normalize__FloatCR"></span><span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a6930a3a2fafce77ef09a261ca41cc130"></span>void <code class="descname">normalize</code><span class="sig-paren">(</span><em class="property">const</em> Float &amp;<em>tolerance</em> = nupic::Epsilon<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor9normalizeERK5Float" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Normalize by adding up the non-zeros across the whole tensor. </p>
<p>Doesn&#8217;t do anything if the sum of the tensor non-zeros adds up to 0. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Friends</p>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> I, <em class="property">typename</em> F&gt;</dt>
<dt>
<span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1acf2e85558b9780e35a8165fa8de0cf73"></span><code class="descname">NTA_HIDDEN friend std::ostream&amp; operator&lt;&lt;(std::ostream &amp; outStream, const  SparseTensor &lt; I, F &gt; &amp; s)</code></dt>
<dd><p>Streaming operator. </p>
<p>See <a class="reference internal" href="#nupic.coreclassnupic_1_1_sparse_tensor_1a69cd48797397cf9b8371481a87c7f9c1"><span class="std std-ref">print()</span></a>. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> I, <em class="property">typename</em> F&gt;</dt>
<dt>
<span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a753a93827a1f94b81ec59e0631ad325a"></span><code class="descname">NTA_HIDDEN friend bool operator==(const  SparseTensor &lt; I, F &gt; &amp; A, const  SparseTensor &lt; I, F &gt; &amp; B)</code></dt>
<dd><p>Whether two sparse tensors are equal or not. </p>
<p>To be equal, they need to have the same number of dimensions, the same size along each dimensions, and the same non-zeros. Equality of floating point numbers is controlled by nupic::Epsilon. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> I, <em class="property">typename</em> F&gt;</dt>
<dt>
<span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1a088dd3be06c334b4b0fc2b315e5b72a5"></span><code class="descname">NTA_HIDDEN friend bool operator!=(const  SparseTensor &lt; I, F &gt; &amp; A, const  SparseTensor &lt; I, F &gt; &amp; B)</code></dt>
<dd><p>Whether two sparse tensors are different or not. </p>
<p>See operator==. </p>
</dd></dl>

</div>
<dl class="class">
<dt>
<span class="target" id="nupic.coreclassnupic_1_1_sparse_tensor_1_1_elt"></span><em class="property">template </em>&lt;<em class="property">typename</em> IndexA, <em class="property">typename</em> IndexB&gt;</dt>
<dt id="_CPPv2N5nupic12SparseTensor3EltE">
<span id="nupic::SparseTensor::Elt"></span><em class="property">class </em><code class="descname">Elt</code><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor3EltE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A small class to carry information about two non-zeros in an intersection or union or sparse tensors of arbitraty (possibly different) ranks. </p>
<p>If the ranks are different, IndexA and IndexB will have different sizes. </p>
</dd></dl>

<dl class="class">
<dt>
<span class="target" id="nupic.corestructnupic_1_1_sparse_tensor_1_1_non_zeros"></span><em class="property">template </em>&lt;typename <em>IndexA</em>, typename <em>IndexB</em>&gt;</dt>
<dt id="_CPPv2N5nupic12SparseTensor8NonZerosE">
<span id="nupic::SparseTensor::NonZeros"></span><em class="property">struct </em><code class="descname">NonZeros</code><a class="headerlink" href="#_CPPv2N5nupic12SparseTensor8NonZerosE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A data structure to hold the non-zero intersection of two tensors of different dimensionalities. </p>
<p>Inherits from std::vector&lt; Elt&lt; IndexA, IndexB &gt; &gt;</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="topology">
<h2>Topology<a class="headerlink" href="#topology" title="Permalink to this headline">¶</a></h2>
<div class="section" id="neighborhood">
<h3>Neighborhood<a class="headerlink" href="#neighborhood" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv2N5nupic4math8topology12NeighborhoodE">
<span id="nupic::math::topology::Neighborhood"></span><span class="target" id="nupic.coreclassnupic_1_1math_1_1topology_1_1_neighborhood"></span><em class="property">class </em><code class="descclassname">nupic::math::topology::</code><code class="descname">Neighborhood</code><a class="headerlink" href="#_CPPv2N5nupic4math8topology12NeighborhoodE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A class that lets you iterate over all points within the neighborhood of a point. </p>
<p>Usage: UInt center = 42; for (UInt neighbor : <a class="reference internal" href="#nupic.coreclassnupic_1_1math_1_1topology_1_1_neighborhood"><span class="std std-ref">Neighborhood</span></a>(center, 10, {100, 100})) { if (neighbor == center) { // Note that the center is included in the neighborhood! } else { // Do something with the neighbor. } }</p>
<p>A point&#8217;s neighborhood is the n-dimensional hypercube with sides ranging [center - radius, center + radius], inclusive. For example, if there are two dimensions and the radius is 3, the neighborhood is 6x6. Neighborhoods are truncated when they are near an edge.</p>
<p><a class="reference internal" href="types.html#nupic.coreclassnupic_1_1_dimensions"><span class="std std-ref">Dimensions</span></a> aren&#8217;t copied  a reference is saved. Make sure the dimensions don&#8217;t get overwritten while this <a class="reference internal" href="#nupic.coreclassnupic_1_1math_1_1topology_1_1_neighborhood"><span class="std std-ref">Neighborhood</span></a> instance exists.</p>
<p>This is designed to be fast. It walks the list of points in the neighborhood without ever creating a list of points.</p>
<p>This still could be faster. Because it handles an arbitrary number of dimensions, it has to allocate vectors. It would be faster to have a Neighborhood1D, Neighborhood2D, etc., so that all computation could occur on the stack, but this would put a burden on callers to handle different dimensions counts. Or it would require using polymorphism, using pointers/references and putting the <a class="reference internal" href="#nupic.coreclassnupic_1_1math_1_1topology_1_1_neighborhood"><span class="std std-ref">Neighborhood</span></a> on the heap, which defeats the purpose of avoiding the vector allocations.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>An object which supports C++ range-based for loops. Each iteration of the loop returns a point in the neighborhood. Each point is expressed as a single index. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">centerIndex</span></code>: The center of this neighborhood. The coordinates are expressed as a single index by using the dimensions as a mixed radix definition. For example, in dimensions 42x10, the point [1, 4] is index 1*420 + 4*10 = 460.</li>
<li><code class="docutils literal"><span class="pre">radius</span></code>: The radius of this neighborhood about the centerIndex.</li>
<li><code class="docutils literal"><span class="pre">dimensions</span></code>: The dimensions of the world outside this neighborhood.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="wrappingneighborhood">
<h3>WrappingNeighborhood<a class="headerlink" href="#wrappingneighborhood" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv2N5nupic4math8topology20WrappingNeighborhoodE">
<span id="nupic::math::topology::WrappingNeighborhood"></span><span class="target" id="nupic.coreclassnupic_1_1math_1_1topology_1_1_wrapping_neighborhood"></span><em class="property">class </em><code class="descclassname">nupic::math::topology::</code><code class="descname">WrappingNeighborhood</code><a class="headerlink" href="#_CPPv2N5nupic4math8topology20WrappingNeighborhoodE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Like the <a class="reference internal" href="#nupic.coreclassnupic_1_1math_1_1topology_1_1_neighborhood"><span class="std std-ref">Neighborhood</span></a> class, except that the neighborhood isn&#8217;t truncated when it&#8217;s near an edge. </p>
<p>It wraps around to the other side.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>An object which supports C++ range-based for loops. Each iteration of the loop returns a point in the neighborhood. Each point is expressed as a single index. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">centerIndex</span></code>: The center of this neighborhood. The coordinates are expressed as a single index by using the dimensions as a mixed radix definition. For example, in dimensions 42x10, the point [1, 4] is index 1*420 + 4*10 = 460.</li>
<li><code class="docutils literal"><span class="pre">radius</span></code>: The radius of this neighborhood about the centerIndex.</li>
<li><code class="docutils literal"><span class="pre">dimensions</span></code>: The dimensions of the world outside this neighborhood.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Math</a><ul>
<li><a class="reference internal" href="#domain">Domain</a></li>
<li><a class="reference internal" href="#index">Index</a></li>
<li><a class="reference internal" href="#nearestneighbor">NearestNeighbor</a></li>
<li><a class="reference internal" href="#segmentmatrixadapter">SegmentMatrixAdapter</a></li>
<li><a class="reference internal" href="#set">Set</a></li>
<li><a class="reference internal" href="#sparsematrixalgorithms">SparseMatrixAlgorithms</a></li>
<li><a class="reference internal" href="#sparsematrixconnections">SparseMatrixConnections</a></li>
<li><a class="reference internal" href="#sparserlematrix">SparseRLEMatrix</a></li>
<li><a class="reference internal" href="#sparsetensor">SparseTensor</a></li>
<li><a class="reference internal" href="#topology">Topology</a><ul>
<li><a class="reference internal" href="#neighborhood">Neighborhood</a></li>
<li><a class="reference internal" href="#wrappingneighborhood">WrappingNeighborhood</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="types.html"
                        title="previous chapter">Types</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="utils.html"
                        title="next chapter">Utilities</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/math.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="utils.html" title="Utilities"
             >next</a> |</li>
        <li class="right" >
          <a href="types.html" title="Types"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">NuPIC Core 0.6.1.dev0
 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Numenta.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
  </body>
</html>