// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SpatialPooler.proto

#ifndef PROTOBUF_SpatialPooler_2eproto__INCLUDED
#define PROTOBUF_SpatialPooler_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace nta {
namespace algorithms {
namespace spatial_pooler {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SpatialPooler_2eproto();
void protobuf_AssignDesc_SpatialPooler_2eproto();
void protobuf_ShutdownFile_SpatialPooler_2eproto();

class SpatialPoolerProto;
class SparseFloat;
class SparseBool;
class SparseRow;
class SparseFloatRow;

// ===================================================================

class SpatialPoolerProto : public ::google::protobuf::MessageLite {
 public:
  SpatialPoolerProto();
  virtual ~SpatialPoolerProto();

  SpatialPoolerProto(const SpatialPoolerProto& from);

  inline SpatialPoolerProto& operator=(const SpatialPoolerProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const SpatialPoolerProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SpatialPoolerProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SpatialPoolerProto* other);

  // implements Message ----------------------------------------------

  SpatialPoolerProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SpatialPoolerProto& from);
  void MergeFrom(const SpatialPoolerProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seed = 1;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 1;
  inline ::google::protobuf::uint32 seed() const;
  inline void set_seed(::google::protobuf::uint32 value);

  // required uint32 numInputs = 2;
  inline bool has_numinputs() const;
  inline void clear_numinputs();
  static const int kNumInputsFieldNumber = 2;
  inline ::google::protobuf::uint32 numinputs() const;
  inline void set_numinputs(::google::protobuf::uint32 value);

  // required uint32 potentialRadius = 3;
  inline bool has_potentialradius() const;
  inline void clear_potentialradius();
  static const int kPotentialRadiusFieldNumber = 3;
  inline ::google::protobuf::uint32 potentialradius() const;
  inline void set_potentialradius(::google::protobuf::uint32 value);

  // required float potentialPct = 4;
  inline bool has_potentialpct() const;
  inline void clear_potentialpct();
  static const int kPotentialPctFieldNumber = 4;
  inline float potentialpct() const;
  inline void set_potentialpct(float value);

  // required bool globalInhibition = 5;
  inline bool has_globalinhibition() const;
  inline void clear_globalinhibition();
  static const int kGlobalInhibitionFieldNumber = 5;
  inline bool globalinhibition() const;
  inline void set_globalinhibition(bool value);

  // required uint32 numActiveColumnsPerInhArea = 6;
  inline bool has_numactivecolumnsperinharea() const;
  inline void clear_numactivecolumnsperinharea();
  static const int kNumActiveColumnsPerInhAreaFieldNumber = 6;
  inline ::google::protobuf::uint32 numactivecolumnsperinharea() const;
  inline void set_numactivecolumnsperinharea(::google::protobuf::uint32 value);

  // required float localAreaDensity = 7;
  inline bool has_localareadensity() const;
  inline void clear_localareadensity();
  static const int kLocalAreaDensityFieldNumber = 7;
  inline float localareadensity() const;
  inline void set_localareadensity(float value);

  // required uint32 stimulusThreshold = 8;
  inline bool has_stimulusthreshold() const;
  inline void clear_stimulusthreshold();
  static const int kStimulusThresholdFieldNumber = 8;
  inline ::google::protobuf::uint32 stimulusthreshold() const;
  inline void set_stimulusthreshold(::google::protobuf::uint32 value);

  // required float synPermInactiveDec = 9;
  inline bool has_synperminactivedec() const;
  inline void clear_synperminactivedec();
  static const int kSynPermInactiveDecFieldNumber = 9;
  inline float synperminactivedec() const;
  inline void set_synperminactivedec(float value);

  // required float synPermActiveInc = 10;
  inline bool has_synpermactiveinc() const;
  inline void clear_synpermactiveinc();
  static const int kSynPermActiveIncFieldNumber = 10;
  inline float synpermactiveinc() const;
  inline void set_synpermactiveinc(float value);

  // required float synPermBelowStimulusInc = 11;
  inline bool has_synpermbelowstimulusinc() const;
  inline void clear_synpermbelowstimulusinc();
  static const int kSynPermBelowStimulusIncFieldNumber = 11;
  inline float synpermbelowstimulusinc() const;
  inline void set_synpermbelowstimulusinc(float value);

  // required float synPermConnected = 12;
  inline bool has_synpermconnected() const;
  inline void clear_synpermconnected();
  static const int kSynPermConnectedFieldNumber = 12;
  inline float synpermconnected() const;
  inline void set_synpermconnected(float value);

  // required float minPctOverlapDutyCycles = 13;
  inline bool has_minpctoverlapdutycycles() const;
  inline void clear_minpctoverlapdutycycles();
  static const int kMinPctOverlapDutyCyclesFieldNumber = 13;
  inline float minpctoverlapdutycycles() const;
  inline void set_minpctoverlapdutycycles(float value);

  // required float minPctActiveDutyCycles = 14;
  inline bool has_minpctactivedutycycles() const;
  inline void clear_minpctactivedutycycles();
  static const int kMinPctActiveDutyCyclesFieldNumber = 14;
  inline float minpctactivedutycycles() const;
  inline void set_minpctactivedutycycles(float value);

  // required uint32 dutyCyclePeriod = 15;
  inline bool has_dutycycleperiod() const;
  inline void clear_dutycycleperiod();
  static const int kDutyCyclePeriodFieldNumber = 15;
  inline ::google::protobuf::uint32 dutycycleperiod() const;
  inline void set_dutycycleperiod(::google::protobuf::uint32 value);

  // required float maxBoost = 16;
  inline bool has_maxboost() const;
  inline void clear_maxboost();
  static const int kMaxBoostFieldNumber = 16;
  inline float maxboost() const;
  inline void set_maxboost(float value);

  // required uint32 spVerbosity = 17;
  inline bool has_spverbosity() const;
  inline void clear_spverbosity();
  static const int kSpVerbosityFieldNumber = 17;
  inline ::google::protobuf::uint32 spverbosity() const;
  inline void set_spverbosity(::google::protobuf::uint32 value);

  // required float synPermMin = 18;
  inline bool has_synpermmin() const;
  inline void clear_synpermmin();
  static const int kSynPermMinFieldNumber = 18;
  inline float synpermmin() const;
  inline void set_synpermmin(float value);

  // required float synPermMax = 19;
  inline bool has_synpermmax() const;
  inline void clear_synpermmax();
  static const int kSynPermMaxFieldNumber = 19;
  inline float synpermmax() const;
  inline void set_synpermmax(float value);

  // required float synPermTrimThreshold = 20;
  inline bool has_synpermtrimthreshold() const;
  inline void clear_synpermtrimthreshold();
  static const int kSynPermTrimThresholdFieldNumber = 20;
  inline float synpermtrimthreshold() const;
  inline void set_synpermtrimthreshold(float value);

  // required uint32 updatePeriod = 21;
  inline bool has_updateperiod() const;
  inline void clear_updateperiod();
  static const int kUpdatePeriodFieldNumber = 21;
  inline ::google::protobuf::uint32 updateperiod() const;
  inline void set_updateperiod(::google::protobuf::uint32 value);

  // required uint32 version = 22;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 22;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required uint32 iterationNum = 23;
  inline bool has_iterationnum() const;
  inline void clear_iterationnum();
  static const int kIterationNumFieldNumber = 23;
  inline ::google::protobuf::uint32 iterationnum() const;
  inline void set_iterationnum(::google::protobuf::uint32 value);

  // required uint32 iterationLearnNum = 24;
  inline bool has_iterationlearnnum() const;
  inline void clear_iterationlearnnum();
  static const int kIterationLearnNumFieldNumber = 24;
  inline ::google::protobuf::uint32 iterationlearnnum() const;
  inline void set_iterationlearnnum(::google::protobuf::uint32 value);

  // required uint32 inhibitionRadius = 25;
  inline bool has_inhibitionradius() const;
  inline void clear_inhibitionradius();
  static const int kInhibitionRadiusFieldNumber = 25;
  inline ::google::protobuf::uint32 inhibitionradius() const;
  inline void set_inhibitionradius(::google::protobuf::uint32 value);

  // repeated uint32 columnDimensions = 26 [packed = true];
  inline int columndimensions_size() const;
  inline void clear_columndimensions();
  static const int kColumnDimensionsFieldNumber = 26;
  inline ::google::protobuf::uint32 columndimensions(int index) const;
  inline void set_columndimensions(int index, ::google::protobuf::uint32 value);
  inline void add_columndimensions(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      columndimensions() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_columndimensions();

  // repeated uint32 inputDimensions = 27 [packed = true];
  inline int inputdimensions_size() const;
  inline void clear_inputdimensions();
  static const int kInputDimensionsFieldNumber = 27;
  inline ::google::protobuf::uint32 inputdimensions(int index) const;
  inline void set_inputdimensions(int index, ::google::protobuf::uint32 value);
  inline void add_inputdimensions(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      inputdimensions() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_inputdimensions();

  // repeated .nta.algorithms.spatial_pooler.SparseRow potentialPools = 28;
  inline int potentialpools_size() const;
  inline void clear_potentialpools();
  static const int kPotentialPoolsFieldNumber = 28;
  inline const ::nta::algorithms::spatial_pooler::SparseRow& potentialpools(int index) const;
  inline ::nta::algorithms::spatial_pooler::SparseRow* mutable_potentialpools(int index);
  inline ::nta::algorithms::spatial_pooler::SparseRow* add_potentialpools();
  inline const ::google::protobuf::RepeatedPtrField< ::nta::algorithms::spatial_pooler::SparseRow >&
      potentialpools() const;
  inline ::google::protobuf::RepeatedPtrField< ::nta::algorithms::spatial_pooler::SparseRow >*
      mutable_potentialpools();

  // repeated .nta.algorithms.spatial_pooler.SparseFloatRow permanences = 29;
  inline int permanences_size() const;
  inline void clear_permanences();
  static const int kPermanencesFieldNumber = 29;
  inline const ::nta::algorithms::spatial_pooler::SparseFloatRow& permanences(int index) const;
  inline ::nta::algorithms::spatial_pooler::SparseFloatRow* mutable_permanences(int index);
  inline ::nta::algorithms::spatial_pooler::SparseFloatRow* add_permanences();
  inline const ::google::protobuf::RepeatedPtrField< ::nta::algorithms::spatial_pooler::SparseFloatRow >&
      permanences() const;
  inline ::google::protobuf::RepeatedPtrField< ::nta::algorithms::spatial_pooler::SparseFloatRow >*
      mutable_permanences();

  // repeated float tieBreaker = 30 [packed = true];
  inline int tiebreaker_size() const;
  inline void clear_tiebreaker();
  static const int kTieBreakerFieldNumber = 30;
  inline float tiebreaker(int index) const;
  inline void set_tiebreaker(int index, float value);
  inline void add_tiebreaker(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      tiebreaker() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_tiebreaker();

  // repeated .nta.algorithms.spatial_pooler.SparseBool connectedSynapses = 31;
  inline int connectedsynapses_size() const;
  inline void clear_connectedsynapses();
  static const int kConnectedSynapsesFieldNumber = 31;
  inline const ::nta::algorithms::spatial_pooler::SparseBool& connectedsynapses(int index) const;
  inline ::nta::algorithms::spatial_pooler::SparseBool* mutable_connectedsynapses(int index);
  inline ::nta::algorithms::spatial_pooler::SparseBool* add_connectedsynapses();
  inline const ::google::protobuf::RepeatedPtrField< ::nta::algorithms::spatial_pooler::SparseBool >&
      connectedsynapses() const;
  inline ::google::protobuf::RepeatedPtrField< ::nta::algorithms::spatial_pooler::SparseBool >*
      mutable_connectedsynapses();

  // repeated uint32 connectedCounts = 32 [packed = true];
  inline int connectedcounts_size() const;
  inline void clear_connectedcounts();
  static const int kConnectedCountsFieldNumber = 32;
  inline ::google::protobuf::uint32 connectedcounts(int index) const;
  inline void set_connectedcounts(int index, ::google::protobuf::uint32 value);
  inline void add_connectedcounts(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      connectedcounts() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_connectedcounts();

  // repeated float overlapDutyCycles = 33 [packed = true];
  inline int overlapdutycycles_size() const;
  inline void clear_overlapdutycycles();
  static const int kOverlapDutyCyclesFieldNumber = 33;
  inline float overlapdutycycles(int index) const;
  inline void set_overlapdutycycles(int index, float value);
  inline void add_overlapdutycycles(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      overlapdutycycles() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_overlapdutycycles();

  // repeated float activeDutyCycles = 34 [packed = true];
  inline int activedutycycles_size() const;
  inline void clear_activedutycycles();
  static const int kActiveDutyCyclesFieldNumber = 34;
  inline float activedutycycles(int index) const;
  inline void set_activedutycycles(int index, float value);
  inline void add_activedutycycles(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      activedutycycles() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_activedutycycles();

  // repeated float minOverlapDutyCycles = 35 [packed = true];
  inline int minoverlapdutycycles_size() const;
  inline void clear_minoverlapdutycycles();
  static const int kMinOverlapDutyCyclesFieldNumber = 35;
  inline float minoverlapdutycycles(int index) const;
  inline void set_minoverlapdutycycles(int index, float value);
  inline void add_minoverlapdutycycles(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      minoverlapdutycycles() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_minoverlapdutycycles();

  // repeated float minActiveDutyCycles = 36 [packed = true];
  inline int minactivedutycycles_size() const;
  inline void clear_minactivedutycycles();
  static const int kMinActiveDutyCyclesFieldNumber = 36;
  inline float minactivedutycycles(int index) const;
  inline void set_minactivedutycycles(int index, float value);
  inline void add_minactivedutycycles(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      minactivedutycycles() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_minactivedutycycles();

  // repeated float boostFactors = 37 [packed = true];
  inline int boostfactors_size() const;
  inline void clear_boostfactors();
  static const int kBoostFactorsFieldNumber = 37;
  inline float boostfactors(int index) const;
  inline void set_boostfactors(int index, float value);
  inline void add_boostfactors(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      boostfactors() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_boostfactors();

  // required uint32 numColumns = 38;
  inline bool has_numcolumns() const;
  inline void clear_numcolumns();
  static const int kNumColumnsFieldNumber = 38;
  inline ::google::protobuf::uint32 numcolumns() const;
  inline void set_numcolumns(::google::protobuf::uint32 value);

  // optional bool isFlatSpatialPooler = 39;
  inline bool has_isflatspatialpooler() const;
  inline void clear_isflatspatialpooler();
  static const int kIsFlatSpatialPoolerFieldNumber = 39;
  inline bool isflatspatialpooler() const;
  inline void set_isflatspatialpooler(bool value);

  // optional float minDistance = 40;
  inline bool has_mindistance() const;
  inline void clear_mindistance();
  static const int kMinDistanceFieldNumber = 40;
  inline float mindistance() const;
  inline void set_mindistance(float value);

  // optional bool randomSP = 41;
  inline bool has_randomsp() const;
  inline void clear_randomsp();
  static const int kRandomSPFieldNumber = 41;
  inline bool randomsp() const;
  inline void set_randomsp(bool value);

  // @@protoc_insertion_point(class_scope:nta.algorithms.spatial_pooler.SpatialPoolerProto)
 private:
  inline void set_has_seed();
  inline void clear_has_seed();
  inline void set_has_numinputs();
  inline void clear_has_numinputs();
  inline void set_has_potentialradius();
  inline void clear_has_potentialradius();
  inline void set_has_potentialpct();
  inline void clear_has_potentialpct();
  inline void set_has_globalinhibition();
  inline void clear_has_globalinhibition();
  inline void set_has_numactivecolumnsperinharea();
  inline void clear_has_numactivecolumnsperinharea();
  inline void set_has_localareadensity();
  inline void clear_has_localareadensity();
  inline void set_has_stimulusthreshold();
  inline void clear_has_stimulusthreshold();
  inline void set_has_synperminactivedec();
  inline void clear_has_synperminactivedec();
  inline void set_has_synpermactiveinc();
  inline void clear_has_synpermactiveinc();
  inline void set_has_synpermbelowstimulusinc();
  inline void clear_has_synpermbelowstimulusinc();
  inline void set_has_synpermconnected();
  inline void clear_has_synpermconnected();
  inline void set_has_minpctoverlapdutycycles();
  inline void clear_has_minpctoverlapdutycycles();
  inline void set_has_minpctactivedutycycles();
  inline void clear_has_minpctactivedutycycles();
  inline void set_has_dutycycleperiod();
  inline void clear_has_dutycycleperiod();
  inline void set_has_maxboost();
  inline void clear_has_maxboost();
  inline void set_has_spverbosity();
  inline void clear_has_spverbosity();
  inline void set_has_synpermmin();
  inline void clear_has_synpermmin();
  inline void set_has_synpermmax();
  inline void clear_has_synpermmax();
  inline void set_has_synpermtrimthreshold();
  inline void clear_has_synpermtrimthreshold();
  inline void set_has_updateperiod();
  inline void clear_has_updateperiod();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_iterationnum();
  inline void clear_has_iterationnum();
  inline void set_has_iterationlearnnum();
  inline void clear_has_iterationlearnnum();
  inline void set_has_inhibitionradius();
  inline void clear_has_inhibitionradius();
  inline void set_has_numcolumns();
  inline void clear_has_numcolumns();
  inline void set_has_isflatspatialpooler();
  inline void clear_has_isflatspatialpooler();
  inline void set_has_mindistance();
  inline void clear_has_mindistance();
  inline void set_has_randomsp();
  inline void clear_has_randomsp();

  ::google::protobuf::uint32 seed_;
  ::google::protobuf::uint32 numinputs_;
  ::google::protobuf::uint32 potentialradius_;
  float potentialpct_;
  ::google::protobuf::uint32 numactivecolumnsperinharea_;
  float localareadensity_;
  ::google::protobuf::uint32 stimulusthreshold_;
  float synperminactivedec_;
  float synpermactiveinc_;
  float synpermbelowstimulusinc_;
  float synpermconnected_;
  float minpctoverlapdutycycles_;
  float minpctactivedutycycles_;
  ::google::protobuf::uint32 dutycycleperiod_;
  float maxboost_;
  ::google::protobuf::uint32 spverbosity_;
  float synpermmin_;
  float synpermmax_;
  float synpermtrimthreshold_;
  ::google::protobuf::uint32 updateperiod_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 iterationnum_;
  ::google::protobuf::uint32 iterationlearnnum_;
  ::google::protobuf::uint32 inhibitionradius_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > columndimensions_;
  mutable int _columndimensions_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > inputdimensions_;
  mutable int _inputdimensions_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::nta::algorithms::spatial_pooler::SparseRow > potentialpools_;
  ::google::protobuf::RepeatedPtrField< ::nta::algorithms::spatial_pooler::SparseFloatRow > permanences_;
  ::google::protobuf::RepeatedField< float > tiebreaker_;
  mutable int _tiebreaker_cached_byte_size_;
  bool globalinhibition_;
  bool isflatspatialpooler_;
  bool randomsp_;
  ::google::protobuf::uint32 numcolumns_;
  ::google::protobuf::RepeatedPtrField< ::nta::algorithms::spatial_pooler::SparseBool > connectedsynapses_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > connectedcounts_;
  mutable int _connectedcounts_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > overlapdutycycles_;
  mutable int _overlapdutycycles_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > activedutycycles_;
  mutable int _activedutycycles_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > minoverlapdutycycles_;
  mutable int _minoverlapdutycycles_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > minactivedutycycles_;
  mutable int _minactivedutycycles_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > boostfactors_;
  mutable int _boostfactors_cached_byte_size_;
  float mindistance_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(41 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SpatialPooler_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SpatialPooler_2eproto();
  #endif
  friend void protobuf_AssignDesc_SpatialPooler_2eproto();
  friend void protobuf_ShutdownFile_SpatialPooler_2eproto();

  void InitAsDefaultInstance();
  static SpatialPoolerProto* default_instance_;
};
// -------------------------------------------------------------------

class SparseFloat : public ::google::protobuf::MessageLite {
 public:
  SparseFloat();
  virtual ~SparseFloat();

  SparseFloat(const SparseFloat& from);

  inline SparseFloat& operator=(const SparseFloat& from) {
    CopyFrom(from);
    return *this;
  }

  static const SparseFloat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SparseFloat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SparseFloat* other);

  // implements Message ----------------------------------------------

  SparseFloat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SparseFloat& from);
  void MergeFrom(const SparseFloat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required float value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline float value() const;
  inline void set_value(float value);

  // @@protoc_insertion_point(class_scope:nta.algorithms.spatial_pooler.SparseFloat)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 index_;
  float value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SpatialPooler_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SpatialPooler_2eproto();
  #endif
  friend void protobuf_AssignDesc_SpatialPooler_2eproto();
  friend void protobuf_ShutdownFile_SpatialPooler_2eproto();

  void InitAsDefaultInstance();
  static SparseFloat* default_instance_;
};
// -------------------------------------------------------------------

class SparseBool : public ::google::protobuf::MessageLite {
 public:
  SparseBool();
  virtual ~SparseBool();

  SparseBool(const SparseBool& from);

  inline SparseBool& operator=(const SparseBool& from) {
    CopyFrom(from);
    return *this;
  }

  static const SparseBool& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SparseBool* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SparseBool* other);

  // implements Message ----------------------------------------------

  SparseBool* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SparseBool& from);
  void MergeFrom(const SparseBool& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required bool value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline bool value() const;
  inline void set_value(bool value);

  // @@protoc_insertion_point(class_scope:nta.algorithms.spatial_pooler.SparseBool)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 index_;
  bool value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SpatialPooler_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SpatialPooler_2eproto();
  #endif
  friend void protobuf_AssignDesc_SpatialPooler_2eproto();
  friend void protobuf_ShutdownFile_SpatialPooler_2eproto();

  void InitAsDefaultInstance();
  static SparseBool* default_instance_;
};
// -------------------------------------------------------------------

class SparseRow : public ::google::protobuf::MessageLite {
 public:
  SparseRow();
  virtual ~SparseRow();

  SparseRow(const SparseRow& from);

  inline SparseRow& operator=(const SparseRow& from) {
    CopyFrom(from);
    return *this;
  }

  static const SparseRow& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SparseRow* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SparseRow* other);

  // implements Message ----------------------------------------------

  SparseRow* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SparseRow& from);
  void MergeFrom(const SparseRow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 rowElements = 1 [packed = true];
  inline int rowelements_size() const;
  inline void clear_rowelements();
  static const int kRowElementsFieldNumber = 1;
  inline ::google::protobuf::uint32 rowelements(int index) const;
  inline void set_rowelements(int index, ::google::protobuf::uint32 value);
  inline void add_rowelements(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      rowelements() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_rowelements();

  // @@protoc_insertion_point(class_scope:nta.algorithms.spatial_pooler.SparseRow)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > rowelements_;
  mutable int _rowelements_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SpatialPooler_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SpatialPooler_2eproto();
  #endif
  friend void protobuf_AssignDesc_SpatialPooler_2eproto();
  friend void protobuf_ShutdownFile_SpatialPooler_2eproto();

  void InitAsDefaultInstance();
  static SparseRow* default_instance_;
};
// -------------------------------------------------------------------

class SparseFloatRow : public ::google::protobuf::MessageLite {
 public:
  SparseFloatRow();
  virtual ~SparseFloatRow();

  SparseFloatRow(const SparseFloatRow& from);

  inline SparseFloatRow& operator=(const SparseFloatRow& from) {
    CopyFrom(from);
    return *this;
  }

  static const SparseFloatRow& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SparseFloatRow* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SparseFloatRow* other);

  // implements Message ----------------------------------------------

  SparseFloatRow* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SparseFloatRow& from);
  void MergeFrom(const SparseFloatRow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 index = 1 [packed = true];
  inline int index_size() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index(int index) const;
  inline void set_index(int index, ::google::protobuf::uint32 value);
  inline void add_index(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      index() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_index();

  // repeated float value = 2 [packed = true];
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline float value(int index) const;
  inline void set_value(int index, float value);
  inline void add_value(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      value() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:nta.algorithms.spatial_pooler.SparseFloatRow)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > index_;
  mutable int _index_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > value_;
  mutable int _value_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SpatialPooler_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SpatialPooler_2eproto();
  #endif
  friend void protobuf_AssignDesc_SpatialPooler_2eproto();
  friend void protobuf_ShutdownFile_SpatialPooler_2eproto();

  void InitAsDefaultInstance();
  static SparseFloatRow* default_instance_;
};
// ===================================================================


// ===================================================================

// SpatialPoolerProto

// required uint32 seed = 1;
inline bool SpatialPoolerProto::has_seed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpatialPoolerProto::set_has_seed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpatialPoolerProto::clear_has_seed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpatialPoolerProto::clear_seed() {
  seed_ = 0u;
  clear_has_seed();
}
inline ::google::protobuf::uint32 SpatialPoolerProto::seed() const {
  return seed_;
}
inline void SpatialPoolerProto::set_seed(::google::protobuf::uint32 value) {
  set_has_seed();
  seed_ = value;
}

// required uint32 numInputs = 2;
inline bool SpatialPoolerProto::has_numinputs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpatialPoolerProto::set_has_numinputs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpatialPoolerProto::clear_has_numinputs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpatialPoolerProto::clear_numinputs() {
  numinputs_ = 0u;
  clear_has_numinputs();
}
inline ::google::protobuf::uint32 SpatialPoolerProto::numinputs() const {
  return numinputs_;
}
inline void SpatialPoolerProto::set_numinputs(::google::protobuf::uint32 value) {
  set_has_numinputs();
  numinputs_ = value;
}

// required uint32 potentialRadius = 3;
inline bool SpatialPoolerProto::has_potentialradius() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpatialPoolerProto::set_has_potentialradius() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpatialPoolerProto::clear_has_potentialradius() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpatialPoolerProto::clear_potentialradius() {
  potentialradius_ = 0u;
  clear_has_potentialradius();
}
inline ::google::protobuf::uint32 SpatialPoolerProto::potentialradius() const {
  return potentialradius_;
}
inline void SpatialPoolerProto::set_potentialradius(::google::protobuf::uint32 value) {
  set_has_potentialradius();
  potentialradius_ = value;
}

// required float potentialPct = 4;
inline bool SpatialPoolerProto::has_potentialpct() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpatialPoolerProto::set_has_potentialpct() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpatialPoolerProto::clear_has_potentialpct() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SpatialPoolerProto::clear_potentialpct() {
  potentialpct_ = 0;
  clear_has_potentialpct();
}
inline float SpatialPoolerProto::potentialpct() const {
  return potentialpct_;
}
inline void SpatialPoolerProto::set_potentialpct(float value) {
  set_has_potentialpct();
  potentialpct_ = value;
}

// required bool globalInhibition = 5;
inline bool SpatialPoolerProto::has_globalinhibition() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SpatialPoolerProto::set_has_globalinhibition() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SpatialPoolerProto::clear_has_globalinhibition() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SpatialPoolerProto::clear_globalinhibition() {
  globalinhibition_ = false;
  clear_has_globalinhibition();
}
inline bool SpatialPoolerProto::globalinhibition() const {
  return globalinhibition_;
}
inline void SpatialPoolerProto::set_globalinhibition(bool value) {
  set_has_globalinhibition();
  globalinhibition_ = value;
}

// required uint32 numActiveColumnsPerInhArea = 6;
inline bool SpatialPoolerProto::has_numactivecolumnsperinharea() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SpatialPoolerProto::set_has_numactivecolumnsperinharea() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SpatialPoolerProto::clear_has_numactivecolumnsperinharea() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SpatialPoolerProto::clear_numactivecolumnsperinharea() {
  numactivecolumnsperinharea_ = 0u;
  clear_has_numactivecolumnsperinharea();
}
inline ::google::protobuf::uint32 SpatialPoolerProto::numactivecolumnsperinharea() const {
  return numactivecolumnsperinharea_;
}
inline void SpatialPoolerProto::set_numactivecolumnsperinharea(::google::protobuf::uint32 value) {
  set_has_numactivecolumnsperinharea();
  numactivecolumnsperinharea_ = value;
}

// required float localAreaDensity = 7;
inline bool SpatialPoolerProto::has_localareadensity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SpatialPoolerProto::set_has_localareadensity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SpatialPoolerProto::clear_has_localareadensity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SpatialPoolerProto::clear_localareadensity() {
  localareadensity_ = 0;
  clear_has_localareadensity();
}
inline float SpatialPoolerProto::localareadensity() const {
  return localareadensity_;
}
inline void SpatialPoolerProto::set_localareadensity(float value) {
  set_has_localareadensity();
  localareadensity_ = value;
}

// required uint32 stimulusThreshold = 8;
inline bool SpatialPoolerProto::has_stimulusthreshold() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SpatialPoolerProto::set_has_stimulusthreshold() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SpatialPoolerProto::clear_has_stimulusthreshold() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SpatialPoolerProto::clear_stimulusthreshold() {
  stimulusthreshold_ = 0u;
  clear_has_stimulusthreshold();
}
inline ::google::protobuf::uint32 SpatialPoolerProto::stimulusthreshold() const {
  return stimulusthreshold_;
}
inline void SpatialPoolerProto::set_stimulusthreshold(::google::protobuf::uint32 value) {
  set_has_stimulusthreshold();
  stimulusthreshold_ = value;
}

// required float synPermInactiveDec = 9;
inline bool SpatialPoolerProto::has_synperminactivedec() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SpatialPoolerProto::set_has_synperminactivedec() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SpatialPoolerProto::clear_has_synperminactivedec() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SpatialPoolerProto::clear_synperminactivedec() {
  synperminactivedec_ = 0;
  clear_has_synperminactivedec();
}
inline float SpatialPoolerProto::synperminactivedec() const {
  return synperminactivedec_;
}
inline void SpatialPoolerProto::set_synperminactivedec(float value) {
  set_has_synperminactivedec();
  synperminactivedec_ = value;
}

// required float synPermActiveInc = 10;
inline bool SpatialPoolerProto::has_synpermactiveinc() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SpatialPoolerProto::set_has_synpermactiveinc() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SpatialPoolerProto::clear_has_synpermactiveinc() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SpatialPoolerProto::clear_synpermactiveinc() {
  synpermactiveinc_ = 0;
  clear_has_synpermactiveinc();
}
inline float SpatialPoolerProto::synpermactiveinc() const {
  return synpermactiveinc_;
}
inline void SpatialPoolerProto::set_synpermactiveinc(float value) {
  set_has_synpermactiveinc();
  synpermactiveinc_ = value;
}

// required float synPermBelowStimulusInc = 11;
inline bool SpatialPoolerProto::has_synpermbelowstimulusinc() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SpatialPoolerProto::set_has_synpermbelowstimulusinc() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SpatialPoolerProto::clear_has_synpermbelowstimulusinc() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SpatialPoolerProto::clear_synpermbelowstimulusinc() {
  synpermbelowstimulusinc_ = 0;
  clear_has_synpermbelowstimulusinc();
}
inline float SpatialPoolerProto::synpermbelowstimulusinc() const {
  return synpermbelowstimulusinc_;
}
inline void SpatialPoolerProto::set_synpermbelowstimulusinc(float value) {
  set_has_synpermbelowstimulusinc();
  synpermbelowstimulusinc_ = value;
}

// required float synPermConnected = 12;
inline bool SpatialPoolerProto::has_synpermconnected() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SpatialPoolerProto::set_has_synpermconnected() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SpatialPoolerProto::clear_has_synpermconnected() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SpatialPoolerProto::clear_synpermconnected() {
  synpermconnected_ = 0;
  clear_has_synpermconnected();
}
inline float SpatialPoolerProto::synpermconnected() const {
  return synpermconnected_;
}
inline void SpatialPoolerProto::set_synpermconnected(float value) {
  set_has_synpermconnected();
  synpermconnected_ = value;
}

// required float minPctOverlapDutyCycles = 13;
inline bool SpatialPoolerProto::has_minpctoverlapdutycycles() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SpatialPoolerProto::set_has_minpctoverlapdutycycles() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SpatialPoolerProto::clear_has_minpctoverlapdutycycles() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SpatialPoolerProto::clear_minpctoverlapdutycycles() {
  minpctoverlapdutycycles_ = 0;
  clear_has_minpctoverlapdutycycles();
}
inline float SpatialPoolerProto::minpctoverlapdutycycles() const {
  return minpctoverlapdutycycles_;
}
inline void SpatialPoolerProto::set_minpctoverlapdutycycles(float value) {
  set_has_minpctoverlapdutycycles();
  minpctoverlapdutycycles_ = value;
}

// required float minPctActiveDutyCycles = 14;
inline bool SpatialPoolerProto::has_minpctactivedutycycles() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SpatialPoolerProto::set_has_minpctactivedutycycles() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SpatialPoolerProto::clear_has_minpctactivedutycycles() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SpatialPoolerProto::clear_minpctactivedutycycles() {
  minpctactivedutycycles_ = 0;
  clear_has_minpctactivedutycycles();
}
inline float SpatialPoolerProto::minpctactivedutycycles() const {
  return minpctactivedutycycles_;
}
inline void SpatialPoolerProto::set_minpctactivedutycycles(float value) {
  set_has_minpctactivedutycycles();
  minpctactivedutycycles_ = value;
}

// required uint32 dutyCyclePeriod = 15;
inline bool SpatialPoolerProto::has_dutycycleperiod() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SpatialPoolerProto::set_has_dutycycleperiod() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SpatialPoolerProto::clear_has_dutycycleperiod() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SpatialPoolerProto::clear_dutycycleperiod() {
  dutycycleperiod_ = 0u;
  clear_has_dutycycleperiod();
}
inline ::google::protobuf::uint32 SpatialPoolerProto::dutycycleperiod() const {
  return dutycycleperiod_;
}
inline void SpatialPoolerProto::set_dutycycleperiod(::google::protobuf::uint32 value) {
  set_has_dutycycleperiod();
  dutycycleperiod_ = value;
}

// required float maxBoost = 16;
inline bool SpatialPoolerProto::has_maxboost() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SpatialPoolerProto::set_has_maxboost() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SpatialPoolerProto::clear_has_maxboost() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SpatialPoolerProto::clear_maxboost() {
  maxboost_ = 0;
  clear_has_maxboost();
}
inline float SpatialPoolerProto::maxboost() const {
  return maxboost_;
}
inline void SpatialPoolerProto::set_maxboost(float value) {
  set_has_maxboost();
  maxboost_ = value;
}

// required uint32 spVerbosity = 17;
inline bool SpatialPoolerProto::has_spverbosity() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SpatialPoolerProto::set_has_spverbosity() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SpatialPoolerProto::clear_has_spverbosity() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SpatialPoolerProto::clear_spverbosity() {
  spverbosity_ = 0u;
  clear_has_spverbosity();
}
inline ::google::protobuf::uint32 SpatialPoolerProto::spverbosity() const {
  return spverbosity_;
}
inline void SpatialPoolerProto::set_spverbosity(::google::protobuf::uint32 value) {
  set_has_spverbosity();
  spverbosity_ = value;
}

// required float synPermMin = 18;
inline bool SpatialPoolerProto::has_synpermmin() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SpatialPoolerProto::set_has_synpermmin() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SpatialPoolerProto::clear_has_synpermmin() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SpatialPoolerProto::clear_synpermmin() {
  synpermmin_ = 0;
  clear_has_synpermmin();
}
inline float SpatialPoolerProto::synpermmin() const {
  return synpermmin_;
}
inline void SpatialPoolerProto::set_synpermmin(float value) {
  set_has_synpermmin();
  synpermmin_ = value;
}

// required float synPermMax = 19;
inline bool SpatialPoolerProto::has_synpermmax() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SpatialPoolerProto::set_has_synpermmax() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SpatialPoolerProto::clear_has_synpermmax() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SpatialPoolerProto::clear_synpermmax() {
  synpermmax_ = 0;
  clear_has_synpermmax();
}
inline float SpatialPoolerProto::synpermmax() const {
  return synpermmax_;
}
inline void SpatialPoolerProto::set_synpermmax(float value) {
  set_has_synpermmax();
  synpermmax_ = value;
}

// required float synPermTrimThreshold = 20;
inline bool SpatialPoolerProto::has_synpermtrimthreshold() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SpatialPoolerProto::set_has_synpermtrimthreshold() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SpatialPoolerProto::clear_has_synpermtrimthreshold() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SpatialPoolerProto::clear_synpermtrimthreshold() {
  synpermtrimthreshold_ = 0;
  clear_has_synpermtrimthreshold();
}
inline float SpatialPoolerProto::synpermtrimthreshold() const {
  return synpermtrimthreshold_;
}
inline void SpatialPoolerProto::set_synpermtrimthreshold(float value) {
  set_has_synpermtrimthreshold();
  synpermtrimthreshold_ = value;
}

// required uint32 updatePeriod = 21;
inline bool SpatialPoolerProto::has_updateperiod() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SpatialPoolerProto::set_has_updateperiod() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SpatialPoolerProto::clear_has_updateperiod() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SpatialPoolerProto::clear_updateperiod() {
  updateperiod_ = 0u;
  clear_has_updateperiod();
}
inline ::google::protobuf::uint32 SpatialPoolerProto::updateperiod() const {
  return updateperiod_;
}
inline void SpatialPoolerProto::set_updateperiod(::google::protobuf::uint32 value) {
  set_has_updateperiod();
  updateperiod_ = value;
}

// required uint32 version = 22;
inline bool SpatialPoolerProto::has_version() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SpatialPoolerProto::set_has_version() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SpatialPoolerProto::clear_has_version() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SpatialPoolerProto::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 SpatialPoolerProto::version() const {
  return version_;
}
inline void SpatialPoolerProto::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// required uint32 iterationNum = 23;
inline bool SpatialPoolerProto::has_iterationnum() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SpatialPoolerProto::set_has_iterationnum() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SpatialPoolerProto::clear_has_iterationnum() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SpatialPoolerProto::clear_iterationnum() {
  iterationnum_ = 0u;
  clear_has_iterationnum();
}
inline ::google::protobuf::uint32 SpatialPoolerProto::iterationnum() const {
  return iterationnum_;
}
inline void SpatialPoolerProto::set_iterationnum(::google::protobuf::uint32 value) {
  set_has_iterationnum();
  iterationnum_ = value;
}

// required uint32 iterationLearnNum = 24;
inline bool SpatialPoolerProto::has_iterationlearnnum() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SpatialPoolerProto::set_has_iterationlearnnum() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SpatialPoolerProto::clear_has_iterationlearnnum() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SpatialPoolerProto::clear_iterationlearnnum() {
  iterationlearnnum_ = 0u;
  clear_has_iterationlearnnum();
}
inline ::google::protobuf::uint32 SpatialPoolerProto::iterationlearnnum() const {
  return iterationlearnnum_;
}
inline void SpatialPoolerProto::set_iterationlearnnum(::google::protobuf::uint32 value) {
  set_has_iterationlearnnum();
  iterationlearnnum_ = value;
}

// required uint32 inhibitionRadius = 25;
inline bool SpatialPoolerProto::has_inhibitionradius() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void SpatialPoolerProto::set_has_inhibitionradius() {
  _has_bits_[0] |= 0x01000000u;
}
inline void SpatialPoolerProto::clear_has_inhibitionradius() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void SpatialPoolerProto::clear_inhibitionradius() {
  inhibitionradius_ = 0u;
  clear_has_inhibitionradius();
}
inline ::google::protobuf::uint32 SpatialPoolerProto::inhibitionradius() const {
  return inhibitionradius_;
}
inline void SpatialPoolerProto::set_inhibitionradius(::google::protobuf::uint32 value) {
  set_has_inhibitionradius();
  inhibitionradius_ = value;
}

// repeated uint32 columnDimensions = 26 [packed = true];
inline int SpatialPoolerProto::columndimensions_size() const {
  return columndimensions_.size();
}
inline void SpatialPoolerProto::clear_columndimensions() {
  columndimensions_.Clear();
}
inline ::google::protobuf::uint32 SpatialPoolerProto::columndimensions(int index) const {
  return columndimensions_.Get(index);
}
inline void SpatialPoolerProto::set_columndimensions(int index, ::google::protobuf::uint32 value) {
  columndimensions_.Set(index, value);
}
inline void SpatialPoolerProto::add_columndimensions(::google::protobuf::uint32 value) {
  columndimensions_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SpatialPoolerProto::columndimensions() const {
  return columndimensions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SpatialPoolerProto::mutable_columndimensions() {
  return &columndimensions_;
}

// repeated uint32 inputDimensions = 27 [packed = true];
inline int SpatialPoolerProto::inputdimensions_size() const {
  return inputdimensions_.size();
}
inline void SpatialPoolerProto::clear_inputdimensions() {
  inputdimensions_.Clear();
}
inline ::google::protobuf::uint32 SpatialPoolerProto::inputdimensions(int index) const {
  return inputdimensions_.Get(index);
}
inline void SpatialPoolerProto::set_inputdimensions(int index, ::google::protobuf::uint32 value) {
  inputdimensions_.Set(index, value);
}
inline void SpatialPoolerProto::add_inputdimensions(::google::protobuf::uint32 value) {
  inputdimensions_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SpatialPoolerProto::inputdimensions() const {
  return inputdimensions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SpatialPoolerProto::mutable_inputdimensions() {
  return &inputdimensions_;
}

// repeated .nta.algorithms.spatial_pooler.SparseRow potentialPools = 28;
inline int SpatialPoolerProto::potentialpools_size() const {
  return potentialpools_.size();
}
inline void SpatialPoolerProto::clear_potentialpools() {
  potentialpools_.Clear();
}
inline const ::nta::algorithms::spatial_pooler::SparseRow& SpatialPoolerProto::potentialpools(int index) const {
  return potentialpools_.Get(index);
}
inline ::nta::algorithms::spatial_pooler::SparseRow* SpatialPoolerProto::mutable_potentialpools(int index) {
  return potentialpools_.Mutable(index);
}
inline ::nta::algorithms::spatial_pooler::SparseRow* SpatialPoolerProto::add_potentialpools() {
  return potentialpools_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nta::algorithms::spatial_pooler::SparseRow >&
SpatialPoolerProto::potentialpools() const {
  return potentialpools_;
}
inline ::google::protobuf::RepeatedPtrField< ::nta::algorithms::spatial_pooler::SparseRow >*
SpatialPoolerProto::mutable_potentialpools() {
  return &potentialpools_;
}

// repeated .nta.algorithms.spatial_pooler.SparseFloatRow permanences = 29;
inline int SpatialPoolerProto::permanences_size() const {
  return permanences_.size();
}
inline void SpatialPoolerProto::clear_permanences() {
  permanences_.Clear();
}
inline const ::nta::algorithms::spatial_pooler::SparseFloatRow& SpatialPoolerProto::permanences(int index) const {
  return permanences_.Get(index);
}
inline ::nta::algorithms::spatial_pooler::SparseFloatRow* SpatialPoolerProto::mutable_permanences(int index) {
  return permanences_.Mutable(index);
}
inline ::nta::algorithms::spatial_pooler::SparseFloatRow* SpatialPoolerProto::add_permanences() {
  return permanences_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nta::algorithms::spatial_pooler::SparseFloatRow >&
SpatialPoolerProto::permanences() const {
  return permanences_;
}
inline ::google::protobuf::RepeatedPtrField< ::nta::algorithms::spatial_pooler::SparseFloatRow >*
SpatialPoolerProto::mutable_permanences() {
  return &permanences_;
}

// repeated float tieBreaker = 30 [packed = true];
inline int SpatialPoolerProto::tiebreaker_size() const {
  return tiebreaker_.size();
}
inline void SpatialPoolerProto::clear_tiebreaker() {
  tiebreaker_.Clear();
}
inline float SpatialPoolerProto::tiebreaker(int index) const {
  return tiebreaker_.Get(index);
}
inline void SpatialPoolerProto::set_tiebreaker(int index, float value) {
  tiebreaker_.Set(index, value);
}
inline void SpatialPoolerProto::add_tiebreaker(float value) {
  tiebreaker_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SpatialPoolerProto::tiebreaker() const {
  return tiebreaker_;
}
inline ::google::protobuf::RepeatedField< float >*
SpatialPoolerProto::mutable_tiebreaker() {
  return &tiebreaker_;
}

// repeated .nta.algorithms.spatial_pooler.SparseBool connectedSynapses = 31;
inline int SpatialPoolerProto::connectedsynapses_size() const {
  return connectedsynapses_.size();
}
inline void SpatialPoolerProto::clear_connectedsynapses() {
  connectedsynapses_.Clear();
}
inline const ::nta::algorithms::spatial_pooler::SparseBool& SpatialPoolerProto::connectedsynapses(int index) const {
  return connectedsynapses_.Get(index);
}
inline ::nta::algorithms::spatial_pooler::SparseBool* SpatialPoolerProto::mutable_connectedsynapses(int index) {
  return connectedsynapses_.Mutable(index);
}
inline ::nta::algorithms::spatial_pooler::SparseBool* SpatialPoolerProto::add_connectedsynapses() {
  return connectedsynapses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nta::algorithms::spatial_pooler::SparseBool >&
SpatialPoolerProto::connectedsynapses() const {
  return connectedsynapses_;
}
inline ::google::protobuf::RepeatedPtrField< ::nta::algorithms::spatial_pooler::SparseBool >*
SpatialPoolerProto::mutable_connectedsynapses() {
  return &connectedsynapses_;
}

// repeated uint32 connectedCounts = 32 [packed = true];
inline int SpatialPoolerProto::connectedcounts_size() const {
  return connectedcounts_.size();
}
inline void SpatialPoolerProto::clear_connectedcounts() {
  connectedcounts_.Clear();
}
inline ::google::protobuf::uint32 SpatialPoolerProto::connectedcounts(int index) const {
  return connectedcounts_.Get(index);
}
inline void SpatialPoolerProto::set_connectedcounts(int index, ::google::protobuf::uint32 value) {
  connectedcounts_.Set(index, value);
}
inline void SpatialPoolerProto::add_connectedcounts(::google::protobuf::uint32 value) {
  connectedcounts_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SpatialPoolerProto::connectedcounts() const {
  return connectedcounts_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SpatialPoolerProto::mutable_connectedcounts() {
  return &connectedcounts_;
}

// repeated float overlapDutyCycles = 33 [packed = true];
inline int SpatialPoolerProto::overlapdutycycles_size() const {
  return overlapdutycycles_.size();
}
inline void SpatialPoolerProto::clear_overlapdutycycles() {
  overlapdutycycles_.Clear();
}
inline float SpatialPoolerProto::overlapdutycycles(int index) const {
  return overlapdutycycles_.Get(index);
}
inline void SpatialPoolerProto::set_overlapdutycycles(int index, float value) {
  overlapdutycycles_.Set(index, value);
}
inline void SpatialPoolerProto::add_overlapdutycycles(float value) {
  overlapdutycycles_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SpatialPoolerProto::overlapdutycycles() const {
  return overlapdutycycles_;
}
inline ::google::protobuf::RepeatedField< float >*
SpatialPoolerProto::mutable_overlapdutycycles() {
  return &overlapdutycycles_;
}

// repeated float activeDutyCycles = 34 [packed = true];
inline int SpatialPoolerProto::activedutycycles_size() const {
  return activedutycycles_.size();
}
inline void SpatialPoolerProto::clear_activedutycycles() {
  activedutycycles_.Clear();
}
inline float SpatialPoolerProto::activedutycycles(int index) const {
  return activedutycycles_.Get(index);
}
inline void SpatialPoolerProto::set_activedutycycles(int index, float value) {
  activedutycycles_.Set(index, value);
}
inline void SpatialPoolerProto::add_activedutycycles(float value) {
  activedutycycles_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SpatialPoolerProto::activedutycycles() const {
  return activedutycycles_;
}
inline ::google::protobuf::RepeatedField< float >*
SpatialPoolerProto::mutable_activedutycycles() {
  return &activedutycycles_;
}

// repeated float minOverlapDutyCycles = 35 [packed = true];
inline int SpatialPoolerProto::minoverlapdutycycles_size() const {
  return minoverlapdutycycles_.size();
}
inline void SpatialPoolerProto::clear_minoverlapdutycycles() {
  minoverlapdutycycles_.Clear();
}
inline float SpatialPoolerProto::minoverlapdutycycles(int index) const {
  return minoverlapdutycycles_.Get(index);
}
inline void SpatialPoolerProto::set_minoverlapdutycycles(int index, float value) {
  minoverlapdutycycles_.Set(index, value);
}
inline void SpatialPoolerProto::add_minoverlapdutycycles(float value) {
  minoverlapdutycycles_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SpatialPoolerProto::minoverlapdutycycles() const {
  return minoverlapdutycycles_;
}
inline ::google::protobuf::RepeatedField< float >*
SpatialPoolerProto::mutable_minoverlapdutycycles() {
  return &minoverlapdutycycles_;
}

// repeated float minActiveDutyCycles = 36 [packed = true];
inline int SpatialPoolerProto::minactivedutycycles_size() const {
  return minactivedutycycles_.size();
}
inline void SpatialPoolerProto::clear_minactivedutycycles() {
  minactivedutycycles_.Clear();
}
inline float SpatialPoolerProto::minactivedutycycles(int index) const {
  return minactivedutycycles_.Get(index);
}
inline void SpatialPoolerProto::set_minactivedutycycles(int index, float value) {
  minactivedutycycles_.Set(index, value);
}
inline void SpatialPoolerProto::add_minactivedutycycles(float value) {
  minactivedutycycles_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SpatialPoolerProto::minactivedutycycles() const {
  return minactivedutycycles_;
}
inline ::google::protobuf::RepeatedField< float >*
SpatialPoolerProto::mutable_minactivedutycycles() {
  return &minactivedutycycles_;
}

// repeated float boostFactors = 37 [packed = true];
inline int SpatialPoolerProto::boostfactors_size() const {
  return boostfactors_.size();
}
inline void SpatialPoolerProto::clear_boostfactors() {
  boostfactors_.Clear();
}
inline float SpatialPoolerProto::boostfactors(int index) const {
  return boostfactors_.Get(index);
}
inline void SpatialPoolerProto::set_boostfactors(int index, float value) {
  boostfactors_.Set(index, value);
}
inline void SpatialPoolerProto::add_boostfactors(float value) {
  boostfactors_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SpatialPoolerProto::boostfactors() const {
  return boostfactors_;
}
inline ::google::protobuf::RepeatedField< float >*
SpatialPoolerProto::mutable_boostfactors() {
  return &boostfactors_;
}

// required uint32 numColumns = 38;
inline bool SpatialPoolerProto::has_numcolumns() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void SpatialPoolerProto::set_has_numcolumns() {
  _has_bits_[1] |= 0x00000020u;
}
inline void SpatialPoolerProto::clear_has_numcolumns() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void SpatialPoolerProto::clear_numcolumns() {
  numcolumns_ = 0u;
  clear_has_numcolumns();
}
inline ::google::protobuf::uint32 SpatialPoolerProto::numcolumns() const {
  return numcolumns_;
}
inline void SpatialPoolerProto::set_numcolumns(::google::protobuf::uint32 value) {
  set_has_numcolumns();
  numcolumns_ = value;
}

// optional bool isFlatSpatialPooler = 39;
inline bool SpatialPoolerProto::has_isflatspatialpooler() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void SpatialPoolerProto::set_has_isflatspatialpooler() {
  _has_bits_[1] |= 0x00000040u;
}
inline void SpatialPoolerProto::clear_has_isflatspatialpooler() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void SpatialPoolerProto::clear_isflatspatialpooler() {
  isflatspatialpooler_ = false;
  clear_has_isflatspatialpooler();
}
inline bool SpatialPoolerProto::isflatspatialpooler() const {
  return isflatspatialpooler_;
}
inline void SpatialPoolerProto::set_isflatspatialpooler(bool value) {
  set_has_isflatspatialpooler();
  isflatspatialpooler_ = value;
}

// optional float minDistance = 40;
inline bool SpatialPoolerProto::has_mindistance() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void SpatialPoolerProto::set_has_mindistance() {
  _has_bits_[1] |= 0x00000080u;
}
inline void SpatialPoolerProto::clear_has_mindistance() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void SpatialPoolerProto::clear_mindistance() {
  mindistance_ = 0;
  clear_has_mindistance();
}
inline float SpatialPoolerProto::mindistance() const {
  return mindistance_;
}
inline void SpatialPoolerProto::set_mindistance(float value) {
  set_has_mindistance();
  mindistance_ = value;
}

// optional bool randomSP = 41;
inline bool SpatialPoolerProto::has_randomsp() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void SpatialPoolerProto::set_has_randomsp() {
  _has_bits_[1] |= 0x00000100u;
}
inline void SpatialPoolerProto::clear_has_randomsp() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void SpatialPoolerProto::clear_randomsp() {
  randomsp_ = false;
  clear_has_randomsp();
}
inline bool SpatialPoolerProto::randomsp() const {
  return randomsp_;
}
inline void SpatialPoolerProto::set_randomsp(bool value) {
  set_has_randomsp();
  randomsp_ = value;
}

// -------------------------------------------------------------------

// SparseFloat

// required uint32 index = 1;
inline bool SparseFloat::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SparseFloat::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SparseFloat::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SparseFloat::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 SparseFloat::index() const {
  return index_;
}
inline void SparseFloat::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required float value = 2;
inline bool SparseFloat::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SparseFloat::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SparseFloat::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SparseFloat::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float SparseFloat::value() const {
  return value_;
}
inline void SparseFloat::set_value(float value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// SparseBool

// required uint32 index = 1;
inline bool SparseBool::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SparseBool::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SparseBool::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SparseBool::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 SparseBool::index() const {
  return index_;
}
inline void SparseBool::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required bool value = 2;
inline bool SparseBool::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SparseBool::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SparseBool::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SparseBool::clear_value() {
  value_ = false;
  clear_has_value();
}
inline bool SparseBool::value() const {
  return value_;
}
inline void SparseBool::set_value(bool value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// SparseRow

// repeated uint32 rowElements = 1 [packed = true];
inline int SparseRow::rowelements_size() const {
  return rowelements_.size();
}
inline void SparseRow::clear_rowelements() {
  rowelements_.Clear();
}
inline ::google::protobuf::uint32 SparseRow::rowelements(int index) const {
  return rowelements_.Get(index);
}
inline void SparseRow::set_rowelements(int index, ::google::protobuf::uint32 value) {
  rowelements_.Set(index, value);
}
inline void SparseRow::add_rowelements(::google::protobuf::uint32 value) {
  rowelements_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SparseRow::rowelements() const {
  return rowelements_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SparseRow::mutable_rowelements() {
  return &rowelements_;
}

// -------------------------------------------------------------------

// SparseFloatRow

// repeated uint32 index = 1 [packed = true];
inline int SparseFloatRow::index_size() const {
  return index_.size();
}
inline void SparseFloatRow::clear_index() {
  index_.Clear();
}
inline ::google::protobuf::uint32 SparseFloatRow::index(int index) const {
  return index_.Get(index);
}
inline void SparseFloatRow::set_index(int index, ::google::protobuf::uint32 value) {
  index_.Set(index, value);
}
inline void SparseFloatRow::add_index(::google::protobuf::uint32 value) {
  index_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SparseFloatRow::index() const {
  return index_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SparseFloatRow::mutable_index() {
  return &index_;
}

// repeated float value = 2 [packed = true];
inline int SparseFloatRow::value_size() const {
  return value_.size();
}
inline void SparseFloatRow::clear_value() {
  value_.Clear();
}
inline float SparseFloatRow::value(int index) const {
  return value_.Get(index);
}
inline void SparseFloatRow::set_value(int index, float value) {
  value_.Set(index, value);
}
inline void SparseFloatRow::add_value(float value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SparseFloatRow::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< float >*
SparseFloatRow::mutable_value() {
  return &value_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace spatial_pooler
}  // namespace algorithms
}  // namespace nta

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SpatialPooler_2eproto__INCLUDED
