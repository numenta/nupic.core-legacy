// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SpatialPooler.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "SpatialPooler.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace nta {
namespace algorithms {
namespace spatial_pooler {

void protobuf_ShutdownFile_SpatialPooler_2eproto() {
  delete SpatialPoolerProto::default_instance_;
  delete SparseFloat::default_instance_;
  delete SparseBool::default_instance_;
  delete SparseRow::default_instance_;
  delete SparseFloatRow::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_SpatialPooler_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_SpatialPooler_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  SpatialPoolerProto::default_instance_ = new SpatialPoolerProto();
  SparseFloat::default_instance_ = new SparseFloat();
  SparseBool::default_instance_ = new SparseBool();
  SparseRow::default_instance_ = new SparseRow();
  SparseFloatRow::default_instance_ = new SparseFloatRow();
  SpatialPoolerProto::default_instance_->InitAsDefaultInstance();
  SparseFloat::default_instance_->InitAsDefaultInstance();
  SparseBool::default_instance_->InitAsDefaultInstance();
  SparseRow::default_instance_->InitAsDefaultInstance();
  SparseFloatRow::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_SpatialPooler_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_SpatialPooler_2eproto_once_);
void protobuf_AddDesc_SpatialPooler_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_SpatialPooler_2eproto_once_,
                 &protobuf_AddDesc_SpatialPooler_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_SpatialPooler_2eproto {
  StaticDescriptorInitializer_SpatialPooler_2eproto() {
    protobuf_AddDesc_SpatialPooler_2eproto();
  }
} static_descriptor_initializer_SpatialPooler_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int SpatialPoolerProto::kSeedFieldNumber;
const int SpatialPoolerProto::kNumInputsFieldNumber;
const int SpatialPoolerProto::kPotentialRadiusFieldNumber;
const int SpatialPoolerProto::kPotentialPctFieldNumber;
const int SpatialPoolerProto::kGlobalInhibitionFieldNumber;
const int SpatialPoolerProto::kNumActiveColumnsPerInhAreaFieldNumber;
const int SpatialPoolerProto::kLocalAreaDensityFieldNumber;
const int SpatialPoolerProto::kStimulusThresholdFieldNumber;
const int SpatialPoolerProto::kSynPermInactiveDecFieldNumber;
const int SpatialPoolerProto::kSynPermActiveIncFieldNumber;
const int SpatialPoolerProto::kSynPermBelowStimulusIncFieldNumber;
const int SpatialPoolerProto::kSynPermConnectedFieldNumber;
const int SpatialPoolerProto::kMinPctOverlapDutyCyclesFieldNumber;
const int SpatialPoolerProto::kMinPctActiveDutyCyclesFieldNumber;
const int SpatialPoolerProto::kDutyCyclePeriodFieldNumber;
const int SpatialPoolerProto::kMaxBoostFieldNumber;
const int SpatialPoolerProto::kSpVerbosityFieldNumber;
const int SpatialPoolerProto::kSynPermMinFieldNumber;
const int SpatialPoolerProto::kSynPermMaxFieldNumber;
const int SpatialPoolerProto::kSynPermTrimThresholdFieldNumber;
const int SpatialPoolerProto::kUpdatePeriodFieldNumber;
const int SpatialPoolerProto::kVersionFieldNumber;
const int SpatialPoolerProto::kIterationNumFieldNumber;
const int SpatialPoolerProto::kIterationLearnNumFieldNumber;
const int SpatialPoolerProto::kInhibitionRadiusFieldNumber;
const int SpatialPoolerProto::kColumnDimensionsFieldNumber;
const int SpatialPoolerProto::kInputDimensionsFieldNumber;
const int SpatialPoolerProto::kPotentialPoolsFieldNumber;
const int SpatialPoolerProto::kPermanencesFieldNumber;
const int SpatialPoolerProto::kTieBreakerFieldNumber;
const int SpatialPoolerProto::kConnectedSynapsesFieldNumber;
const int SpatialPoolerProto::kConnectedCountsFieldNumber;
const int SpatialPoolerProto::kOverlapDutyCyclesFieldNumber;
const int SpatialPoolerProto::kActiveDutyCyclesFieldNumber;
const int SpatialPoolerProto::kMinOverlapDutyCyclesFieldNumber;
const int SpatialPoolerProto::kMinActiveDutyCyclesFieldNumber;
const int SpatialPoolerProto::kBoostFactorsFieldNumber;
const int SpatialPoolerProto::kNumColumnsFieldNumber;
const int SpatialPoolerProto::kIsFlatSpatialPoolerFieldNumber;
const int SpatialPoolerProto::kMinDistanceFieldNumber;
const int SpatialPoolerProto::kRandomSPFieldNumber;
#endif  // !_MSC_VER

SpatialPoolerProto::SpatialPoolerProto()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SpatialPoolerProto::InitAsDefaultInstance() {
}

SpatialPoolerProto::SpatialPoolerProto(const SpatialPoolerProto& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SpatialPoolerProto::SharedCtor() {
  _cached_size_ = 0;
  seed_ = 0u;
  numinputs_ = 0u;
  potentialradius_ = 0u;
  potentialpct_ = 0;
  globalinhibition_ = false;
  numactivecolumnsperinharea_ = 0u;
  localareadensity_ = 0;
  stimulusthreshold_ = 0u;
  synperminactivedec_ = 0;
  synpermactiveinc_ = 0;
  synpermbelowstimulusinc_ = 0;
  synpermconnected_ = 0;
  minpctoverlapdutycycles_ = 0;
  minpctactivedutycycles_ = 0;
  dutycycleperiod_ = 0u;
  maxboost_ = 0;
  spverbosity_ = 0u;
  synpermmin_ = 0;
  synpermmax_ = 0;
  synpermtrimthreshold_ = 0;
  updateperiod_ = 0u;
  version_ = 0u;
  iterationnum_ = 0u;
  iterationlearnnum_ = 0u;
  inhibitionradius_ = 0u;
  numcolumns_ = 0u;
  isflatspatialpooler_ = false;
  mindistance_ = 0;
  randomsp_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SpatialPoolerProto::~SpatialPoolerProto() {
  SharedDtor();
}

void SpatialPoolerProto::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SpatialPoolerProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SpatialPoolerProto& SpatialPoolerProto::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_SpatialPooler_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_SpatialPooler_2eproto();
#endif
  return *default_instance_;
}

SpatialPoolerProto* SpatialPoolerProto::default_instance_ = NULL;

SpatialPoolerProto* SpatialPoolerProto::New() const {
  return new SpatialPoolerProto;
}

void SpatialPoolerProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    seed_ = 0u;
    numinputs_ = 0u;
    potentialradius_ = 0u;
    potentialpct_ = 0;
    globalinhibition_ = false;
    numactivecolumnsperinharea_ = 0u;
    localareadensity_ = 0;
    stimulusthreshold_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    synperminactivedec_ = 0;
    synpermactiveinc_ = 0;
    synpermbelowstimulusinc_ = 0;
    synpermconnected_ = 0;
    minpctoverlapdutycycles_ = 0;
    minpctactivedutycycles_ = 0;
    dutycycleperiod_ = 0u;
    maxboost_ = 0;
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    spverbosity_ = 0u;
    synpermmin_ = 0;
    synpermmax_ = 0;
    synpermtrimthreshold_ = 0;
    updateperiod_ = 0u;
    version_ = 0u;
    iterationnum_ = 0u;
    iterationlearnnum_ = 0u;
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    inhibitionradius_ = 0u;
  }
  if (_has_bits_[37 / 32] & (0xffu << (37 % 32))) {
    numcolumns_ = 0u;
    isflatspatialpooler_ = false;
    mindistance_ = 0;
  }
  if (_has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    randomsp_ = false;
  }
  columndimensions_.Clear();
  inputdimensions_.Clear();
  potentialpools_.Clear();
  permanences_.Clear();
  tiebreaker_.Clear();
  connectedsynapses_.Clear();
  connectedcounts_.Clear();
  overlapdutycycles_.Clear();
  activedutycycles_.Clear();
  minoverlapdutycycles_.Clear();
  minactivedutycycles_.Clear();
  boostfactors_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SpatialPoolerProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 seed = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &seed_)));
          set_has_seed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_numInputs;
        break;
      }

      // required uint32 numInputs = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_numInputs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &numinputs_)));
          set_has_numinputs();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_potentialRadius;
        break;
      }

      // required uint32 potentialRadius = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_potentialRadius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &potentialradius_)));
          set_has_potentialradius();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_potentialPct;
        break;
      }

      // required float potentialPct = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_potentialPct:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &potentialpct_)));
          set_has_potentialpct();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_globalInhibition;
        break;
      }

      // required bool globalInhibition = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_globalInhibition:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &globalinhibition_)));
          set_has_globalinhibition();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_numActiveColumnsPerInhArea;
        break;
      }

      // required uint32 numActiveColumnsPerInhArea = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_numActiveColumnsPerInhArea:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &numactivecolumnsperinharea_)));
          set_has_numactivecolumnsperinharea();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_localAreaDensity;
        break;
      }

      // required float localAreaDensity = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_localAreaDensity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &localareadensity_)));
          set_has_localareadensity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_stimulusThreshold;
        break;
      }

      // required uint32 stimulusThreshold = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_stimulusThreshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &stimulusthreshold_)));
          set_has_stimulusthreshold();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_synPermInactiveDec;
        break;
      }

      // required float synPermInactiveDec = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_synPermInactiveDec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &synperminactivedec_)));
          set_has_synperminactivedec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(85)) goto parse_synPermActiveInc;
        break;
      }

      // required float synPermActiveInc = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_synPermActiveInc:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &synpermactiveinc_)));
          set_has_synpermactiveinc();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(93)) goto parse_synPermBelowStimulusInc;
        break;
      }

      // required float synPermBelowStimulusInc = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_synPermBelowStimulusInc:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &synpermbelowstimulusinc_)));
          set_has_synpermbelowstimulusinc();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(101)) goto parse_synPermConnected;
        break;
      }

      // required float synPermConnected = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_synPermConnected:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &synpermconnected_)));
          set_has_synpermconnected();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(109)) goto parse_minPctOverlapDutyCycles;
        break;
      }

      // required float minPctOverlapDutyCycles = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_minPctOverlapDutyCycles:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &minpctoverlapdutycycles_)));
          set_has_minpctoverlapdutycycles();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(117)) goto parse_minPctActiveDutyCycles;
        break;
      }

      // required float minPctActiveDutyCycles = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_minPctActiveDutyCycles:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &minpctactivedutycycles_)));
          set_has_minpctactivedutycycles();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_dutyCyclePeriod;
        break;
      }

      // required uint32 dutyCyclePeriod = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_dutyCyclePeriod:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dutycycleperiod_)));
          set_has_dutycycleperiod();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(133)) goto parse_maxBoost;
        break;
      }

      // required float maxBoost = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_maxBoost:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &maxboost_)));
          set_has_maxboost();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(136)) goto parse_spVerbosity;
        break;
      }

      // required uint32 spVerbosity = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_spVerbosity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &spverbosity_)));
          set_has_spverbosity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(149)) goto parse_synPermMin;
        break;
      }

      // required float synPermMin = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_synPermMin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &synpermmin_)));
          set_has_synpermmin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(157)) goto parse_synPermMax;
        break;
      }

      // required float synPermMax = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_synPermMax:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &synpermmax_)));
          set_has_synpermmax();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(165)) goto parse_synPermTrimThreshold;
        break;
      }

      // required float synPermTrimThreshold = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_synPermTrimThreshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &synpermtrimthreshold_)));
          set_has_synpermtrimthreshold();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(168)) goto parse_updatePeriod;
        break;
      }

      // required uint32 updatePeriod = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_updatePeriod:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &updateperiod_)));
          set_has_updateperiod();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(176)) goto parse_version;
        break;
      }

      // required uint32 version = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(184)) goto parse_iterationNum;
        break;
      }

      // required uint32 iterationNum = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_iterationNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &iterationnum_)));
          set_has_iterationnum();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(192)) goto parse_iterationLearnNum;
        break;
      }

      // required uint32 iterationLearnNum = 24;
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_iterationLearnNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &iterationlearnnum_)));
          set_has_iterationlearnnum();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(200)) goto parse_inhibitionRadius;
        break;
      }

      // required uint32 inhibitionRadius = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_inhibitionRadius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &inhibitionradius_)));
          set_has_inhibitionradius();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(210)) goto parse_columnDimensions;
        break;
      }

      // repeated uint32 columnDimensions = 26 [packed = true];
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_columnDimensions:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_columndimensions())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 2, 210, input, this->mutable_columndimensions())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(218)) goto parse_inputDimensions;
        break;
      }

      // repeated uint32 inputDimensions = 27 [packed = true];
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_inputDimensions:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_inputdimensions())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 2, 218, input, this->mutable_inputdimensions())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(226)) goto parse_potentialPools;
        break;
      }

      // repeated .nta.algorithms.spatial_pooler.SparseRow potentialPools = 28;
      case 28: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_potentialPools:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_potentialpools()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(226)) goto parse_potentialPools;
        if (input->ExpectTag(234)) goto parse_permanences;
        break;
      }

      // repeated .nta.algorithms.spatial_pooler.SparseFloatRow permanences = 29;
      case 29: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_permanences:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_permanences()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(234)) goto parse_permanences;
        if (input->ExpectTag(242)) goto parse_tieBreaker;
        break;
      }

      // repeated float tieBreaker = 30 [packed = true];
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tieBreaker:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_tiebreaker())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 2, 242, input, this->mutable_tiebreaker())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(250)) goto parse_connectedSynapses;
        break;
      }

      // repeated .nta.algorithms.spatial_pooler.SparseBool connectedSynapses = 31;
      case 31: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_connectedSynapses:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_connectedsynapses()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(250)) goto parse_connectedSynapses;
        if (input->ExpectTag(258)) goto parse_connectedCounts;
        break;
      }

      // repeated uint32 connectedCounts = 32 [packed = true];
      case 32: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_connectedCounts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_connectedcounts())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 2, 258, input, this->mutable_connectedcounts())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(266)) goto parse_overlapDutyCycles;
        break;
      }

      // repeated float overlapDutyCycles = 33 [packed = true];
      case 33: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_overlapDutyCycles:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_overlapdutycycles())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 2, 266, input, this->mutable_overlapdutycycles())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(274)) goto parse_activeDutyCycles;
        break;
      }

      // repeated float activeDutyCycles = 34 [packed = true];
      case 34: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_activeDutyCycles:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_activedutycycles())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 2, 274, input, this->mutable_activedutycycles())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(282)) goto parse_minOverlapDutyCycles;
        break;
      }

      // repeated float minOverlapDutyCycles = 35 [packed = true];
      case 35: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_minOverlapDutyCycles:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_minoverlapdutycycles())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 2, 282, input, this->mutable_minoverlapdutycycles())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(290)) goto parse_minActiveDutyCycles;
        break;
      }

      // repeated float minActiveDutyCycles = 36 [packed = true];
      case 36: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_minActiveDutyCycles:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_minactivedutycycles())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 2, 290, input, this->mutable_minactivedutycycles())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(298)) goto parse_boostFactors;
        break;
      }

      // repeated float boostFactors = 37 [packed = true];
      case 37: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_boostFactors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_boostfactors())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 2, 298, input, this->mutable_boostfactors())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(304)) goto parse_numColumns;
        break;
      }

      // required uint32 numColumns = 38;
      case 38: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_numColumns:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &numcolumns_)));
          set_has_numcolumns();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(312)) goto parse_isFlatSpatialPooler;
        break;
      }

      // optional bool isFlatSpatialPooler = 39;
      case 39: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isFlatSpatialPooler:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isflatspatialpooler_)));
          set_has_isflatspatialpooler();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(325)) goto parse_minDistance;
        break;
      }

      // optional float minDistance = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_minDistance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &mindistance_)));
          set_has_mindistance();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(328)) goto parse_randomSP;
        break;
      }

      // optional bool randomSP = 41;
      case 41: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_randomSP:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &randomsp_)));
          set_has_randomsp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SpatialPoolerProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 seed = 1;
  if (has_seed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->seed(), output);
  }

  // required uint32 numInputs = 2;
  if (has_numinputs()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->numinputs(), output);
  }

  // required uint32 potentialRadius = 3;
  if (has_potentialradius()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->potentialradius(), output);
  }

  // required float potentialPct = 4;
  if (has_potentialpct()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->potentialpct(), output);
  }

  // required bool globalInhibition = 5;
  if (has_globalinhibition()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->globalinhibition(), output);
  }

  // required uint32 numActiveColumnsPerInhArea = 6;
  if (has_numactivecolumnsperinharea()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->numactivecolumnsperinharea(), output);
  }

  // required float localAreaDensity = 7;
  if (has_localareadensity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->localareadensity(), output);
  }

  // required uint32 stimulusThreshold = 8;
  if (has_stimulusthreshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->stimulusthreshold(), output);
  }

  // required float synPermInactiveDec = 9;
  if (has_synperminactivedec()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->synperminactivedec(), output);
  }

  // required float synPermActiveInc = 10;
  if (has_synpermactiveinc()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->synpermactiveinc(), output);
  }

  // required float synPermBelowStimulusInc = 11;
  if (has_synpermbelowstimulusinc()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->synpermbelowstimulusinc(), output);
  }

  // required float synPermConnected = 12;
  if (has_synpermconnected()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->synpermconnected(), output);
  }

  // required float minPctOverlapDutyCycles = 13;
  if (has_minpctoverlapdutycycles()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->minpctoverlapdutycycles(), output);
  }

  // required float minPctActiveDutyCycles = 14;
  if (has_minpctactivedutycycles()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(14, this->minpctactivedutycycles(), output);
  }

  // required uint32 dutyCyclePeriod = 15;
  if (has_dutycycleperiod()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->dutycycleperiod(), output);
  }

  // required float maxBoost = 16;
  if (has_maxboost()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(16, this->maxboost(), output);
  }

  // required uint32 spVerbosity = 17;
  if (has_spverbosity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(17, this->spverbosity(), output);
  }

  // required float synPermMin = 18;
  if (has_synpermmin()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(18, this->synpermmin(), output);
  }

  // required float synPermMax = 19;
  if (has_synpermmax()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(19, this->synpermmax(), output);
  }

  // required float synPermTrimThreshold = 20;
  if (has_synpermtrimthreshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(20, this->synpermtrimthreshold(), output);
  }

  // required uint32 updatePeriod = 21;
  if (has_updateperiod()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(21, this->updateperiod(), output);
  }

  // required uint32 version = 22;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(22, this->version(), output);
  }

  // required uint32 iterationNum = 23;
  if (has_iterationnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(23, this->iterationnum(), output);
  }

  // required uint32 iterationLearnNum = 24;
  if (has_iterationlearnnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(24, this->iterationlearnnum(), output);
  }

  // required uint32 inhibitionRadius = 25;
  if (has_inhibitionradius()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(25, this->inhibitionradius(), output);
  }

  // repeated uint32 columnDimensions = 26 [packed = true];
  if (this->columndimensions_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(26, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_columndimensions_cached_byte_size_);
  }
  for (int i = 0; i < this->columndimensions_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->columndimensions(i), output);
  }

  // repeated uint32 inputDimensions = 27 [packed = true];
  if (this->inputdimensions_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(27, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_inputdimensions_cached_byte_size_);
  }
  for (int i = 0; i < this->inputdimensions_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->inputdimensions(i), output);
  }

  // repeated .nta.algorithms.spatial_pooler.SparseRow potentialPools = 28;
  for (int i = 0; i < this->potentialpools_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      28, this->potentialpools(i), output);
  }

  // repeated .nta.algorithms.spatial_pooler.SparseFloatRow permanences = 29;
  for (int i = 0; i < this->permanences_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      29, this->permanences(i), output);
  }

  // repeated float tieBreaker = 30 [packed = true];
  if (this->tiebreaker_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(30, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_tiebreaker_cached_byte_size_);
  }
  for (int i = 0; i < this->tiebreaker_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloatNoTag(
      this->tiebreaker(i), output);
  }

  // repeated .nta.algorithms.spatial_pooler.SparseBool connectedSynapses = 31;
  for (int i = 0; i < this->connectedsynapses_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      31, this->connectedsynapses(i), output);
  }

  // repeated uint32 connectedCounts = 32 [packed = true];
  if (this->connectedcounts_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(32, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_connectedcounts_cached_byte_size_);
  }
  for (int i = 0; i < this->connectedcounts_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->connectedcounts(i), output);
  }

  // repeated float overlapDutyCycles = 33 [packed = true];
  if (this->overlapdutycycles_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(33, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_overlapdutycycles_cached_byte_size_);
  }
  for (int i = 0; i < this->overlapdutycycles_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloatNoTag(
      this->overlapdutycycles(i), output);
  }

  // repeated float activeDutyCycles = 34 [packed = true];
  if (this->activedutycycles_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(34, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_activedutycycles_cached_byte_size_);
  }
  for (int i = 0; i < this->activedutycycles_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloatNoTag(
      this->activedutycycles(i), output);
  }

  // repeated float minOverlapDutyCycles = 35 [packed = true];
  if (this->minoverlapdutycycles_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(35, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_minoverlapdutycycles_cached_byte_size_);
  }
  for (int i = 0; i < this->minoverlapdutycycles_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloatNoTag(
      this->minoverlapdutycycles(i), output);
  }

  // repeated float minActiveDutyCycles = 36 [packed = true];
  if (this->minactivedutycycles_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(36, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_minactivedutycycles_cached_byte_size_);
  }
  for (int i = 0; i < this->minactivedutycycles_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloatNoTag(
      this->minactivedutycycles(i), output);
  }

  // repeated float boostFactors = 37 [packed = true];
  if (this->boostfactors_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(37, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_boostfactors_cached_byte_size_);
  }
  for (int i = 0; i < this->boostfactors_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloatNoTag(
      this->boostfactors(i), output);
  }

  // required uint32 numColumns = 38;
  if (has_numcolumns()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(38, this->numcolumns(), output);
  }

  // optional bool isFlatSpatialPooler = 39;
  if (has_isflatspatialpooler()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(39, this->isflatspatialpooler(), output);
  }

  // optional float minDistance = 40;
  if (has_mindistance()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(40, this->mindistance(), output);
  }

  // optional bool randomSP = 41;
  if (has_randomsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(41, this->randomsp(), output);
  }

}

int SpatialPoolerProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 seed = 1;
    if (has_seed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->seed());
    }

    // required uint32 numInputs = 2;
    if (has_numinputs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->numinputs());
    }

    // required uint32 potentialRadius = 3;
    if (has_potentialradius()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->potentialradius());
    }

    // required float potentialPct = 4;
    if (has_potentialpct()) {
      total_size += 1 + 4;
    }

    // required bool globalInhibition = 5;
    if (has_globalinhibition()) {
      total_size += 1 + 1;
    }

    // required uint32 numActiveColumnsPerInhArea = 6;
    if (has_numactivecolumnsperinharea()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->numactivecolumnsperinharea());
    }

    // required float localAreaDensity = 7;
    if (has_localareadensity()) {
      total_size += 1 + 4;
    }

    // required uint32 stimulusThreshold = 8;
    if (has_stimulusthreshold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->stimulusthreshold());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required float synPermInactiveDec = 9;
    if (has_synperminactivedec()) {
      total_size += 1 + 4;
    }

    // required float synPermActiveInc = 10;
    if (has_synpermactiveinc()) {
      total_size += 1 + 4;
    }

    // required float synPermBelowStimulusInc = 11;
    if (has_synpermbelowstimulusinc()) {
      total_size += 1 + 4;
    }

    // required float synPermConnected = 12;
    if (has_synpermconnected()) {
      total_size += 1 + 4;
    }

    // required float minPctOverlapDutyCycles = 13;
    if (has_minpctoverlapdutycycles()) {
      total_size += 1 + 4;
    }

    // required float minPctActiveDutyCycles = 14;
    if (has_minpctactivedutycycles()) {
      total_size += 1 + 4;
    }

    // required uint32 dutyCyclePeriod = 15;
    if (has_dutycycleperiod()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dutycycleperiod());
    }

    // required float maxBoost = 16;
    if (has_maxboost()) {
      total_size += 2 + 4;
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // required uint32 spVerbosity = 17;
    if (has_spverbosity()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->spverbosity());
    }

    // required float synPermMin = 18;
    if (has_synpermmin()) {
      total_size += 2 + 4;
    }

    // required float synPermMax = 19;
    if (has_synpermmax()) {
      total_size += 2 + 4;
    }

    // required float synPermTrimThreshold = 20;
    if (has_synpermtrimthreshold()) {
      total_size += 2 + 4;
    }

    // required uint32 updatePeriod = 21;
    if (has_updateperiod()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->updateperiod());
    }

    // required uint32 version = 22;
    if (has_version()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // required uint32 iterationNum = 23;
    if (has_iterationnum()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->iterationnum());
    }

    // required uint32 iterationLearnNum = 24;
    if (has_iterationlearnnum()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->iterationlearnnum());
    }

  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // required uint32 inhibitionRadius = 25;
    if (has_inhibitionradius()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->inhibitionradius());
    }

  }
  if (_has_bits_[37 / 32] & (0xffu << (37 % 32))) {
    // required uint32 numColumns = 38;
    if (has_numcolumns()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->numcolumns());
    }

    // optional bool isFlatSpatialPooler = 39;
    if (has_isflatspatialpooler()) {
      total_size += 2 + 1;
    }

    // optional float minDistance = 40;
    if (has_mindistance()) {
      total_size += 2 + 4;
    }

  }
  if (_has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    // optional bool randomSP = 41;
    if (has_randomsp()) {
      total_size += 2 + 1;
    }

  }
  // repeated uint32 columnDimensions = 26 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->columndimensions_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->columndimensions(i));
    }
    if (data_size > 0) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _columndimensions_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated uint32 inputDimensions = 27 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->inputdimensions_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->inputdimensions(i));
    }
    if (data_size > 0) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _inputdimensions_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated .nta.algorithms.spatial_pooler.SparseRow potentialPools = 28;
  total_size += 2 * this->potentialpools_size();
  for (int i = 0; i < this->potentialpools_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->potentialpools(i));
  }

  // repeated .nta.algorithms.spatial_pooler.SparseFloatRow permanences = 29;
  total_size += 2 * this->permanences_size();
  for (int i = 0; i < this->permanences_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->permanences(i));
  }

  // repeated float tieBreaker = 30 [packed = true];
  {
    int data_size = 0;
    data_size = 4 * this->tiebreaker_size();
    if (data_size > 0) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _tiebreaker_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated .nta.algorithms.spatial_pooler.SparseBool connectedSynapses = 31;
  total_size += 2 * this->connectedsynapses_size();
  for (int i = 0; i < this->connectedsynapses_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->connectedsynapses(i));
  }

  // repeated uint32 connectedCounts = 32 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->connectedcounts_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->connectedcounts(i));
    }
    if (data_size > 0) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _connectedcounts_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated float overlapDutyCycles = 33 [packed = true];
  {
    int data_size = 0;
    data_size = 4 * this->overlapdutycycles_size();
    if (data_size > 0) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _overlapdutycycles_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated float activeDutyCycles = 34 [packed = true];
  {
    int data_size = 0;
    data_size = 4 * this->activedutycycles_size();
    if (data_size > 0) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _activedutycycles_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated float minOverlapDutyCycles = 35 [packed = true];
  {
    int data_size = 0;
    data_size = 4 * this->minoverlapdutycycles_size();
    if (data_size > 0) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _minoverlapdutycycles_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated float minActiveDutyCycles = 36 [packed = true];
  {
    int data_size = 0;
    data_size = 4 * this->minactivedutycycles_size();
    if (data_size > 0) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _minactivedutycycles_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated float boostFactors = 37 [packed = true];
  {
    int data_size = 0;
    data_size = 4 * this->boostfactors_size();
    if (data_size > 0) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _boostfactors_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SpatialPoolerProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SpatialPoolerProto*>(&from));
}

void SpatialPoolerProto::MergeFrom(const SpatialPoolerProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  columndimensions_.MergeFrom(from.columndimensions_);
  inputdimensions_.MergeFrom(from.inputdimensions_);
  potentialpools_.MergeFrom(from.potentialpools_);
  permanences_.MergeFrom(from.permanences_);
  tiebreaker_.MergeFrom(from.tiebreaker_);
  connectedsynapses_.MergeFrom(from.connectedsynapses_);
  connectedcounts_.MergeFrom(from.connectedcounts_);
  overlapdutycycles_.MergeFrom(from.overlapdutycycles_);
  activedutycycles_.MergeFrom(from.activedutycycles_);
  minoverlapdutycycles_.MergeFrom(from.minoverlapdutycycles_);
  minactivedutycycles_.MergeFrom(from.minactivedutycycles_);
  boostfactors_.MergeFrom(from.boostfactors_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seed()) {
      set_seed(from.seed());
    }
    if (from.has_numinputs()) {
      set_numinputs(from.numinputs());
    }
    if (from.has_potentialradius()) {
      set_potentialradius(from.potentialradius());
    }
    if (from.has_potentialpct()) {
      set_potentialpct(from.potentialpct());
    }
    if (from.has_globalinhibition()) {
      set_globalinhibition(from.globalinhibition());
    }
    if (from.has_numactivecolumnsperinharea()) {
      set_numactivecolumnsperinharea(from.numactivecolumnsperinharea());
    }
    if (from.has_localareadensity()) {
      set_localareadensity(from.localareadensity());
    }
    if (from.has_stimulusthreshold()) {
      set_stimulusthreshold(from.stimulusthreshold());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_synperminactivedec()) {
      set_synperminactivedec(from.synperminactivedec());
    }
    if (from.has_synpermactiveinc()) {
      set_synpermactiveinc(from.synpermactiveinc());
    }
    if (from.has_synpermbelowstimulusinc()) {
      set_synpermbelowstimulusinc(from.synpermbelowstimulusinc());
    }
    if (from.has_synpermconnected()) {
      set_synpermconnected(from.synpermconnected());
    }
    if (from.has_minpctoverlapdutycycles()) {
      set_minpctoverlapdutycycles(from.minpctoverlapdutycycles());
    }
    if (from.has_minpctactivedutycycles()) {
      set_minpctactivedutycycles(from.minpctactivedutycycles());
    }
    if (from.has_dutycycleperiod()) {
      set_dutycycleperiod(from.dutycycleperiod());
    }
    if (from.has_maxboost()) {
      set_maxboost(from.maxboost());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_spverbosity()) {
      set_spverbosity(from.spverbosity());
    }
    if (from.has_synpermmin()) {
      set_synpermmin(from.synpermmin());
    }
    if (from.has_synpermmax()) {
      set_synpermmax(from.synpermmax());
    }
    if (from.has_synpermtrimthreshold()) {
      set_synpermtrimthreshold(from.synpermtrimthreshold());
    }
    if (from.has_updateperiod()) {
      set_updateperiod(from.updateperiod());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_iterationnum()) {
      set_iterationnum(from.iterationnum());
    }
    if (from.has_iterationlearnnum()) {
      set_iterationlearnnum(from.iterationlearnnum());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_inhibitionradius()) {
      set_inhibitionradius(from.inhibitionradius());
    }
  }
  if (from._has_bits_[37 / 32] & (0xffu << (37 % 32))) {
    if (from.has_numcolumns()) {
      set_numcolumns(from.numcolumns());
    }
    if (from.has_isflatspatialpooler()) {
      set_isflatspatialpooler(from.isflatspatialpooler());
    }
    if (from.has_mindistance()) {
      set_mindistance(from.mindistance());
    }
  }
  if (from._has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    if (from.has_randomsp()) {
      set_randomsp(from.randomsp());
    }
  }
}

void SpatialPoolerProto::CopyFrom(const SpatialPoolerProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpatialPoolerProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x01ffffff) != 0x01ffffff) return false;
  if ((_has_bits_[1] & 0x00000020) != 0x00000020) return false;

  for (int i = 0; i < connectedsynapses_size(); i++) {
    if (!this->connectedsynapses(i).IsInitialized()) return false;
  }
  return true;
}

void SpatialPoolerProto::Swap(SpatialPoolerProto* other) {
  if (other != this) {
    std::swap(seed_, other->seed_);
    std::swap(numinputs_, other->numinputs_);
    std::swap(potentialradius_, other->potentialradius_);
    std::swap(potentialpct_, other->potentialpct_);
    std::swap(globalinhibition_, other->globalinhibition_);
    std::swap(numactivecolumnsperinharea_, other->numactivecolumnsperinharea_);
    std::swap(localareadensity_, other->localareadensity_);
    std::swap(stimulusthreshold_, other->stimulusthreshold_);
    std::swap(synperminactivedec_, other->synperminactivedec_);
    std::swap(synpermactiveinc_, other->synpermactiveinc_);
    std::swap(synpermbelowstimulusinc_, other->synpermbelowstimulusinc_);
    std::swap(synpermconnected_, other->synpermconnected_);
    std::swap(minpctoverlapdutycycles_, other->minpctoverlapdutycycles_);
    std::swap(minpctactivedutycycles_, other->minpctactivedutycycles_);
    std::swap(dutycycleperiod_, other->dutycycleperiod_);
    std::swap(maxboost_, other->maxboost_);
    std::swap(spverbosity_, other->spverbosity_);
    std::swap(synpermmin_, other->synpermmin_);
    std::swap(synpermmax_, other->synpermmax_);
    std::swap(synpermtrimthreshold_, other->synpermtrimthreshold_);
    std::swap(updateperiod_, other->updateperiod_);
    std::swap(version_, other->version_);
    std::swap(iterationnum_, other->iterationnum_);
    std::swap(iterationlearnnum_, other->iterationlearnnum_);
    std::swap(inhibitionradius_, other->inhibitionradius_);
    columndimensions_.Swap(&other->columndimensions_);
    inputdimensions_.Swap(&other->inputdimensions_);
    potentialpools_.Swap(&other->potentialpools_);
    permanences_.Swap(&other->permanences_);
    tiebreaker_.Swap(&other->tiebreaker_);
    connectedsynapses_.Swap(&other->connectedsynapses_);
    connectedcounts_.Swap(&other->connectedcounts_);
    overlapdutycycles_.Swap(&other->overlapdutycycles_);
    activedutycycles_.Swap(&other->activedutycycles_);
    minoverlapdutycycles_.Swap(&other->minoverlapdutycycles_);
    minactivedutycycles_.Swap(&other->minactivedutycycles_);
    boostfactors_.Swap(&other->boostfactors_);
    std::swap(numcolumns_, other->numcolumns_);
    std::swap(isflatspatialpooler_, other->isflatspatialpooler_);
    std::swap(mindistance_, other->mindistance_);
    std::swap(randomsp_, other->randomsp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_has_bits_[1], other->_has_bits_[1]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SpatialPoolerProto::GetTypeName() const {
  return "nta.algorithms.spatial_pooler.SpatialPoolerProto";
}


// ===================================================================

#ifndef _MSC_VER
const int SparseFloat::kIndexFieldNumber;
const int SparseFloat::kValueFieldNumber;
#endif  // !_MSC_VER

SparseFloat::SparseFloat()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SparseFloat::InitAsDefaultInstance() {
}

SparseFloat::SparseFloat(const SparseFloat& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SparseFloat::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0u;
  value_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SparseFloat::~SparseFloat() {
  SharedDtor();
}

void SparseFloat::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SparseFloat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SparseFloat& SparseFloat::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_SpatialPooler_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_SpatialPooler_2eproto();
#endif
  return *default_instance_;
}

SparseFloat* SparseFloat::default_instance_ = NULL;

SparseFloat* SparseFloat::New() const {
  return new SparseFloat;
}

void SparseFloat::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    index_ = 0u;
    value_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SparseFloat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_value;
        break;
      }

      // required float value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SparseFloat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->index(), output);
  }

  // required float value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->value(), output);
  }

}

int SparseFloat::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // required float value = 2;
    if (has_value()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SparseFloat::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SparseFloat*>(&from));
}

void SparseFloat::MergeFrom(const SparseFloat& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void SparseFloat::CopyFrom(const SparseFloat& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SparseFloat::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SparseFloat::Swap(SparseFloat* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SparseFloat::GetTypeName() const {
  return "nta.algorithms.spatial_pooler.SparseFloat";
}


// ===================================================================

#ifndef _MSC_VER
const int SparseBool::kIndexFieldNumber;
const int SparseBool::kValueFieldNumber;
#endif  // !_MSC_VER

SparseBool::SparseBool()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SparseBool::InitAsDefaultInstance() {
}

SparseBool::SparseBool(const SparseBool& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SparseBool::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0u;
  value_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SparseBool::~SparseBool() {
  SharedDtor();
}

void SparseBool::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SparseBool::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SparseBool& SparseBool::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_SpatialPooler_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_SpatialPooler_2eproto();
#endif
  return *default_instance_;
}

SparseBool* SparseBool::default_instance_ = NULL;

SparseBool* SparseBool::New() const {
  return new SparseBool;
}

void SparseBool::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    index_ = 0u;
    value_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SparseBool::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_value;
        break;
      }

      // required bool value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SparseBool::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->index(), output);
  }

  // required bool value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->value(), output);
  }

}

int SparseBool::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // required bool value = 2;
    if (has_value()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SparseBool::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SparseBool*>(&from));
}

void SparseBool::MergeFrom(const SparseBool& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void SparseBool::CopyFrom(const SparseBool& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SparseBool::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SparseBool::Swap(SparseBool* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SparseBool::GetTypeName() const {
  return "nta.algorithms.spatial_pooler.SparseBool";
}


// ===================================================================

#ifndef _MSC_VER
const int SparseRow::kRowElementsFieldNumber;
#endif  // !_MSC_VER

SparseRow::SparseRow()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SparseRow::InitAsDefaultInstance() {
}

SparseRow::SparseRow(const SparseRow& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SparseRow::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SparseRow::~SparseRow() {
  SharedDtor();
}

void SparseRow::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SparseRow::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SparseRow& SparseRow::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_SpatialPooler_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_SpatialPooler_2eproto();
#endif
  return *default_instance_;
}

SparseRow* SparseRow::default_instance_ = NULL;

SparseRow* SparseRow::New() const {
  return new SparseRow;
}

void SparseRow::Clear() {
  rowelements_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SparseRow::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 rowElements = 1 [packed = true];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_rowelements())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 10, input, this->mutable_rowelements())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SparseRow::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 rowElements = 1 [packed = true];
  if (this->rowelements_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_rowelements_cached_byte_size_);
  }
  for (int i = 0; i < this->rowelements_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->rowelements(i), output);
  }

}

int SparseRow::ByteSize() const {
  int total_size = 0;

  // repeated uint32 rowElements = 1 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->rowelements_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->rowelements(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _rowelements_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SparseRow::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SparseRow*>(&from));
}

void SparseRow::MergeFrom(const SparseRow& from) {
  GOOGLE_CHECK_NE(&from, this);
  rowelements_.MergeFrom(from.rowelements_);
}

void SparseRow::CopyFrom(const SparseRow& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SparseRow::IsInitialized() const {

  return true;
}

void SparseRow::Swap(SparseRow* other) {
  if (other != this) {
    rowelements_.Swap(&other->rowelements_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SparseRow::GetTypeName() const {
  return "nta.algorithms.spatial_pooler.SparseRow";
}


// ===================================================================

#ifndef _MSC_VER
const int SparseFloatRow::kIndexFieldNumber;
const int SparseFloatRow::kValueFieldNumber;
#endif  // !_MSC_VER

SparseFloatRow::SparseFloatRow()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SparseFloatRow::InitAsDefaultInstance() {
}

SparseFloatRow::SparseFloatRow(const SparseFloatRow& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SparseFloatRow::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SparseFloatRow::~SparseFloatRow() {
  SharedDtor();
}

void SparseFloatRow::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SparseFloatRow::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SparseFloatRow& SparseFloatRow::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_SpatialPooler_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_SpatialPooler_2eproto();
#endif
  return *default_instance_;
}

SparseFloatRow* SparseFloatRow::default_instance_ = NULL;

SparseFloatRow* SparseFloatRow::New() const {
  return new SparseFloatRow;
}

void SparseFloatRow::Clear() {
  index_.Clear();
  value_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SparseFloatRow::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 index = 1 [packed = true];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_index())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 10, input, this->mutable_index())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // repeated float value = 2 [packed = true];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_value())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 18, input, this->mutable_value())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SparseFloatRow::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 index = 1 [packed = true];
  if (this->index_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_index_cached_byte_size_);
  }
  for (int i = 0; i < this->index_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->index(i), output);
  }

  // repeated float value = 2 [packed = true];
  if (this->value_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(2, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_value_cached_byte_size_);
  }
  for (int i = 0; i < this->value_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloatNoTag(
      this->value(i), output);
  }

}

int SparseFloatRow::ByteSize() const {
  int total_size = 0;

  // repeated uint32 index = 1 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->index_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->index(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _index_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated float value = 2 [packed = true];
  {
    int data_size = 0;
    data_size = 4 * this->value_size();
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _value_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SparseFloatRow::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SparseFloatRow*>(&from));
}

void SparseFloatRow::MergeFrom(const SparseFloatRow& from) {
  GOOGLE_CHECK_NE(&from, this);
  index_.MergeFrom(from.index_);
  value_.MergeFrom(from.value_);
}

void SparseFloatRow::CopyFrom(const SparseFloatRow& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SparseFloatRow::IsInitialized() const {

  return true;
}

void SparseFloatRow::Swap(SparseFloatRow* other) {
  if (other != this) {
    index_.Swap(&other->index_);
    value_.Swap(&other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SparseFloatRow::GetTypeName() const {
  return "nta.algorithms.spatial_pooler.SparseFloatRow";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace spatial_pooler
}  // namespace algorithms
}  // namespace nta

// @@protoc_insertion_point(global_scope)
